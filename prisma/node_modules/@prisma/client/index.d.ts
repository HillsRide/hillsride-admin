
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model SystemSetting
 * 
 */
export type SystemSetting = $Result.DefaultSelection<Prisma.$SystemSettingPayload>
/**
 * Model SearchHistory
 * 
 */
export type SearchHistory = $Result.DefaultSelection<Prisma.$SearchHistoryPayload>
/**
 * Model LocationDemandAnalytics
 * 
 */
export type LocationDemandAnalytics = $Result.DefaultSelection<Prisma.$LocationDemandAnalyticsPayload>
/**
 * Model PricingAnalytics
 * 
 */
export type PricingAnalytics = $Result.DefaultSelection<Prisma.$PricingAnalyticsPayload>
/**
 * Model Location
 * 
 */
export type Location = $Result.DefaultSelection<Prisma.$LocationPayload>
/**
 * Model Route
 * 
 */
export type Route = $Result.DefaultSelection<Prisma.$RoutePayload>
/**
 * Model Stop
 * 
 */
export type Stop = $Result.DefaultSelection<Prisma.$StopPayload>
/**
 * Model RouteFare
 * 
 */
export type RouteFare = $Result.DefaultSelection<Prisma.$RouteFarePayload>
/**
 * Model RouteAvailability
 * 
 */
export type RouteAvailability = $Result.DefaultSelection<Prisma.$RouteAvailabilityPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSetting`: Exposes CRUD operations for the **SystemSetting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSetting.findMany()
    * ```
    */
  get systemSetting(): Prisma.SystemSettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.searchHistory`: Exposes CRUD operations for the **SearchHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchHistories
    * const searchHistories = await prisma.searchHistory.findMany()
    * ```
    */
  get searchHistory(): Prisma.SearchHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locationDemandAnalytics`: Exposes CRUD operations for the **LocationDemandAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationDemandAnalytics
    * const locationDemandAnalytics = await prisma.locationDemandAnalytics.findMany()
    * ```
    */
  get locationDemandAnalytics(): Prisma.LocationDemandAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pricingAnalytics`: Exposes CRUD operations for the **PricingAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PricingAnalytics
    * const pricingAnalytics = await prisma.pricingAnalytics.findMany()
    * ```
    */
  get pricingAnalytics(): Prisma.PricingAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.location`: Exposes CRUD operations for the **Location** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Locations
    * const locations = await prisma.location.findMany()
    * ```
    */
  get location(): Prisma.LocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.route`: Exposes CRUD operations for the **Route** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Routes
    * const routes = await prisma.route.findMany()
    * ```
    */
  get route(): Prisma.RouteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stop`: Exposes CRUD operations for the **Stop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stops
    * const stops = await prisma.stop.findMany()
    * ```
    */
  get stop(): Prisma.StopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.routeFare`: Exposes CRUD operations for the **RouteFare** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RouteFares
    * const routeFares = await prisma.routeFare.findMany()
    * ```
    */
  get routeFare(): Prisma.RouteFareDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.routeAvailability`: Exposes CRUD operations for the **RouteAvailability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RouteAvailabilities
    * const routeAvailabilities = await prisma.routeAvailability.findMany()
    * ```
    */
  get routeAvailability(): Prisma.RouteAvailabilityDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    SystemSetting: 'SystemSetting',
    SearchHistory: 'SearchHistory',
    LocationDemandAnalytics: 'LocationDemandAnalytics',
    PricingAnalytics: 'PricingAnalytics',
    Location: 'Location',
    Route: 'Route',
    Stop: 'Stop',
    RouteFare: 'RouteFare',
    RouteAvailability: 'RouteAvailability'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "systemSetting" | "searchHistory" | "locationDemandAnalytics" | "pricingAnalytics" | "location" | "route" | "stop" | "routeFare" | "routeAvailability"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      SystemSetting: {
        payload: Prisma.$SystemSettingPayload<ExtArgs>
        fields: Prisma.SystemSettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          findMany: {
            args: Prisma.SystemSettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>[]
          }
          create: {
            args: Prisma.SystemSettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          createMany: {
            args: Prisma.SystemSettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SystemSettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          update: {
            args: Prisma.SystemSettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemSettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSetting>
          }
          groupBy: {
            args: Prisma.SystemSettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingCountAggregateOutputType> | number
          }
        }
      }
      SearchHistory: {
        payload: Prisma.$SearchHistoryPayload<ExtArgs>
        fields: Prisma.SearchHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findFirst: {
            args: Prisma.SearchHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findMany: {
            args: Prisma.SearchHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          create: {
            args: Prisma.SearchHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          createMany: {
            args: Prisma.SearchHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SearchHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          update: {
            args: Prisma.SearchHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SearchHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SearchHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          aggregate: {
            args: Prisma.SearchHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchHistory>
          }
          groupBy: {
            args: Prisma.SearchHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryCountAggregateOutputType> | number
          }
        }
      }
      LocationDemandAnalytics: {
        payload: Prisma.$LocationDemandAnalyticsPayload<ExtArgs>
        fields: Prisma.LocationDemandAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationDemandAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDemandAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationDemandAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDemandAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.LocationDemandAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDemandAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationDemandAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDemandAnalyticsPayload>
          }
          findMany: {
            args: Prisma.LocationDemandAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDemandAnalyticsPayload>[]
          }
          create: {
            args: Prisma.LocationDemandAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDemandAnalyticsPayload>
          }
          createMany: {
            args: Prisma.LocationDemandAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LocationDemandAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDemandAnalyticsPayload>
          }
          update: {
            args: Prisma.LocationDemandAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDemandAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.LocationDemandAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationDemandAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationDemandAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationDemandAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.LocationDemandAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationDemandAnalytics>
          }
          groupBy: {
            args: Prisma.LocationDemandAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationDemandAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationDemandAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<LocationDemandAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      PricingAnalytics: {
        payload: Prisma.$PricingAnalyticsPayload<ExtArgs>
        fields: Prisma.PricingAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PricingAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PricingAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.PricingAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PricingAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingAnalyticsPayload>
          }
          findMany: {
            args: Prisma.PricingAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingAnalyticsPayload>[]
          }
          create: {
            args: Prisma.PricingAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingAnalyticsPayload>
          }
          createMany: {
            args: Prisma.PricingAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PricingAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingAnalyticsPayload>
          }
          update: {
            args: Prisma.PricingAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.PricingAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PricingAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PricingAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PricingAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.PricingAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePricingAnalytics>
          }
          groupBy: {
            args: Prisma.PricingAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PricingAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PricingAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<PricingAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      Location: {
        payload: Prisma.$LocationPayload<ExtArgs>
        fields: Prisma.LocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findFirst: {
            args: Prisma.LocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          findMany: {
            args: Prisma.LocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>[]
          }
          create: {
            args: Prisma.LocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          createMany: {
            args: Prisma.LocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          update: {
            args: Prisma.LocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          deleteMany: {
            args: Prisma.LocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationPayload>
          }
          aggregate: {
            args: Prisma.LocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocation>
          }
          groupBy: {
            args: Prisma.LocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationCountArgs<ExtArgs>
            result: $Utils.Optional<LocationCountAggregateOutputType> | number
          }
        }
      }
      Route: {
        payload: Prisma.$RoutePayload<ExtArgs>
        fields: Prisma.RouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          findFirst: {
            args: Prisma.RouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          findMany: {
            args: Prisma.RouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>[]
          }
          create: {
            args: Prisma.RouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          createMany: {
            args: Prisma.RouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          update: {
            args: Prisma.RouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          deleteMany: {
            args: Prisma.RouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutePayload>
          }
          aggregate: {
            args: Prisma.RouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoute>
          }
          groupBy: {
            args: Prisma.RouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteCountArgs<ExtArgs>
            result: $Utils.Optional<RouteCountAggregateOutputType> | number
          }
        }
      }
      Stop: {
        payload: Prisma.$StopPayload<ExtArgs>
        fields: Prisma.StopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          findFirst: {
            args: Prisma.StopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          findMany: {
            args: Prisma.StopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>[]
          }
          create: {
            args: Prisma.StopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          createMany: {
            args: Prisma.StopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          update: {
            args: Prisma.StopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          deleteMany: {
            args: Prisma.StopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StopPayload>
          }
          aggregate: {
            args: Prisma.StopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStop>
          }
          groupBy: {
            args: Prisma.StopGroupByArgs<ExtArgs>
            result: $Utils.Optional<StopGroupByOutputType>[]
          }
          count: {
            args: Prisma.StopCountArgs<ExtArgs>
            result: $Utils.Optional<StopCountAggregateOutputType> | number
          }
        }
      }
      RouteFare: {
        payload: Prisma.$RouteFarePayload<ExtArgs>
        fields: Prisma.RouteFareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteFareFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFarePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteFareFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFarePayload>
          }
          findFirst: {
            args: Prisma.RouteFareFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFarePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteFareFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFarePayload>
          }
          findMany: {
            args: Prisma.RouteFareFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFarePayload>[]
          }
          create: {
            args: Prisma.RouteFareCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFarePayload>
          }
          createMany: {
            args: Prisma.RouteFareCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RouteFareDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFarePayload>
          }
          update: {
            args: Prisma.RouteFareUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFarePayload>
          }
          deleteMany: {
            args: Prisma.RouteFareDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteFareUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RouteFareUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteFarePayload>
          }
          aggregate: {
            args: Prisma.RouteFareAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRouteFare>
          }
          groupBy: {
            args: Prisma.RouteFareGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteFareGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteFareCountArgs<ExtArgs>
            result: $Utils.Optional<RouteFareCountAggregateOutputType> | number
          }
        }
      }
      RouteAvailability: {
        payload: Prisma.$RouteAvailabilityPayload<ExtArgs>
        fields: Prisma.RouteAvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteAvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteAvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteAvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteAvailabilityPayload>
          }
          findFirst: {
            args: Prisma.RouteAvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteAvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteAvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteAvailabilityPayload>
          }
          findMany: {
            args: Prisma.RouteAvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteAvailabilityPayload>[]
          }
          create: {
            args: Prisma.RouteAvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteAvailabilityPayload>
          }
          createMany: {
            args: Prisma.RouteAvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RouteAvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteAvailabilityPayload>
          }
          update: {
            args: Prisma.RouteAvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteAvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.RouteAvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteAvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RouteAvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteAvailabilityPayload>
          }
          aggregate: {
            args: Prisma.RouteAvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRouteAvailability>
          }
          groupBy: {
            args: Prisma.RouteAvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteAvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteAvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<RouteAvailabilityCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    systemSetting?: SystemSettingOmit
    searchHistory?: SearchHistoryOmit
    locationDemandAnalytics?: LocationDemandAnalyticsOmit
    pricingAnalytics?: PricingAnalyticsOmit
    location?: LocationOmit
    route?: RouteOmit
    stop?: StopOmit
    routeFare?: RouteFareOmit
    routeAvailability?: RouteAvailabilityOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    searches: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    searches?: boolean | UserCountOutputTypeCountSearchesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSearchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
  }


  /**
   * Count Type LocationCountOutputType
   */

  export type LocationCountOutputType = {
    routesFrom: number
    routesTo: number
    stops: number
  }

  export type LocationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routesFrom?: boolean | LocationCountOutputTypeCountRoutesFromArgs
    routesTo?: boolean | LocationCountOutputTypeCountRoutesToArgs
    stops?: boolean | LocationCountOutputTypeCountStopsArgs
  }

  // Custom InputTypes
  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationCountOutputType
     */
    select?: LocationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountRoutesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountRoutesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteWhereInput
  }

  /**
   * LocationCountOutputType without action
   */
  export type LocationCountOutputTypeCountStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopWhereInput
  }


  /**
   * Count Type RouteCountOutputType
   */

  export type RouteCountOutputType = {
    stops: number
    fares: number
    availability: number
  }

  export type RouteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stops?: boolean | RouteCountOutputTypeCountStopsArgs
    fares?: boolean | RouteCountOutputTypeCountFaresArgs
    availability?: boolean | RouteCountOutputTypeCountAvailabilityArgs
  }

  // Custom InputTypes
  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteCountOutputType
     */
    select?: RouteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeCountStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopWhereInput
  }

  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeCountFaresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteFareWhereInput
  }

  /**
   * RouteCountOutputType without action
   */
  export type RouteCountOutputTypeCountAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteAvailabilityWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    fullName: string | null
    email: string | null
    phone: string | null
    employeeId: string | null
    designation: string | null
    department: string | null
    manager: string | null
    approver: string | null
    password: string | null
    pin: string | null
    authCode: string | null
    status: string | null
    needsPasswordChange: boolean | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    fullName: string | null
    email: string | null
    phone: string | null
    employeeId: string | null
    designation: string | null
    department: string | null
    manager: string | null
    approver: string | null
    password: string | null
    pin: string | null
    authCode: string | null
    status: string | null
    needsPasswordChange: boolean | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    fullName: number
    email: number
    phone: number
    employeeId: number
    designation: number
    department: number
    manager: number
    approver: number
    password: number
    pin: number
    authCode: number
    status: number
    needsPasswordChange: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    phone?: true
    employeeId?: true
    designation?: true
    department?: true
    manager?: true
    approver?: true
    password?: true
    pin?: true
    authCode?: true
    status?: true
    needsPasswordChange?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    phone?: true
    employeeId?: true
    designation?: true
    department?: true
    manager?: true
    approver?: true
    password?: true
    pin?: true
    authCode?: true
    status?: true
    needsPasswordChange?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    fullName?: true
    email?: true
    phone?: true
    employeeId?: true
    designation?: true
    department?: true
    manager?: true
    approver?: true
    password?: true
    pin?: true
    authCode?: true
    status?: true
    needsPasswordChange?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    fullName: string
    email: string
    phone: string
    employeeId: string
    designation: string
    department: string
    manager: string
    approver: string
    password: string | null
    pin: string | null
    authCode: string | null
    status: string
    needsPasswordChange: boolean
    role: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    employeeId?: boolean
    designation?: boolean
    department?: boolean
    manager?: boolean
    approver?: boolean
    password?: boolean
    pin?: boolean
    authCode?: boolean
    status?: boolean
    needsPasswordChange?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    searches?: boolean | User$searchesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    fullName?: boolean
    email?: boolean
    phone?: boolean
    employeeId?: boolean
    designation?: boolean
    department?: boolean
    manager?: boolean
    approver?: boolean
    password?: boolean
    pin?: boolean
    authCode?: boolean
    status?: boolean
    needsPasswordChange?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullName" | "email" | "phone" | "employeeId" | "designation" | "department" | "manager" | "approver" | "password" | "pin" | "authCode" | "status" | "needsPasswordChange" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    searches?: boolean | User$searchesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      searches: Prisma.$SearchHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullName: string
      email: string
      phone: string
      employeeId: string
      designation: string
      department: string
      manager: string
      approver: string
      password: string | null
      pin: string | null
      authCode: string | null
      status: string
      needsPasswordChange: boolean
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    searches<T extends User$searchesArgs<ExtArgs> = {}>(args?: Subset<T, User$searchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly employeeId: FieldRef<"User", 'String'>
    readonly designation: FieldRef<"User", 'String'>
    readonly department: FieldRef<"User", 'String'>
    readonly manager: FieldRef<"User", 'String'>
    readonly approver: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly pin: FieldRef<"User", 'String'>
    readonly authCode: FieldRef<"User", 'String'>
    readonly status: FieldRef<"User", 'String'>
    readonly needsPasswordChange: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.searches
   */
  export type User$searchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    cursor?: SearchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model SystemSetting
   */

  export type AggregateSystemSetting = {
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  export type SystemSettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemSettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemSettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemSettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemSettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSetting to aggregate.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingMaxAggregateInputType
  }

  export type GetSystemSettingAggregateType<T extends SystemSettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSetting[P]>
      : GetScalarType<T[P], AggregateSystemSetting[P]>
  }




  export type SystemSettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingWhereInput
    orderBy?: SystemSettingOrderByWithAggregationInput | SystemSettingOrderByWithAggregationInput[]
    by: SystemSettingScalarFieldEnum[] | SystemSettingScalarFieldEnum
    having?: SystemSettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingCountAggregateInputType | true
    _min?: SystemSettingMinAggregateInputType
    _max?: SystemSettingMaxAggregateInputType
  }

  export type SystemSettingGroupByOutputType = {
    id: string
    key: string
    value: string
    createdAt: Date
    updatedAt: Date
    _count: SystemSettingCountAggregateOutputType | null
    _min: SystemSettingMinAggregateOutputType | null
    _max: SystemSettingMaxAggregateOutputType | null
  }

  type GetSystemSettingGroupByPayload<T extends SystemSettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemSetting"]>



  export type SystemSettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemSettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "createdAt" | "updatedAt", ExtArgs["result"]["systemSetting"]>

  export type $SystemSettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSetting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemSetting"]>
    composites: {}
  }

  type SystemSettingGetPayload<S extends boolean | null | undefined | SystemSettingDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingPayload, S>

  type SystemSettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingCountAggregateInputType | true
    }

  export interface SystemSettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSetting'], meta: { name: 'SystemSetting' } }
    /**
     * Find zero or one SystemSetting that matches the filter.
     * @param {SystemSettingFindUniqueArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingFindUniqueArgs>(args: SelectSubset<T, SystemSettingFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSetting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingFindUniqueOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingFindFirstArgs>(args?: SelectSubset<T, SystemSettingFindFirstArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSetting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindFirstOrThrowArgs} args - Arguments to find a SystemSetting
     * @example
     * // Get one SystemSetting
     * const systemSetting = await prisma.systemSetting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSetting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingWithIdOnly = await prisma.systemSetting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingFindManyArgs>(args?: SelectSubset<T, SystemSettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSetting.
     * @param {SystemSettingCreateArgs} args - Arguments to create a SystemSetting.
     * @example
     * // Create one SystemSetting
     * const SystemSetting = await prisma.systemSetting.create({
     *   data: {
     *     // ... data to create a SystemSetting
     *   }
     * })
     * 
     */
    create<T extends SystemSettingCreateArgs>(args: SelectSubset<T, SystemSettingCreateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSetting = await prisma.systemSetting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingCreateManyArgs>(args?: SelectSubset<T, SystemSettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SystemSetting.
     * @param {SystemSettingDeleteArgs} args - Arguments to delete one SystemSetting.
     * @example
     * // Delete one SystemSetting
     * const SystemSetting = await prisma.systemSetting.delete({
     *   where: {
     *     // ... filter to delete one SystemSetting
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingDeleteArgs>(args: SelectSubset<T, SystemSettingDeleteArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSetting.
     * @param {SystemSettingUpdateArgs} args - Arguments to update one SystemSetting.
     * @example
     * // Update one SystemSetting
     * const systemSetting = await prisma.systemSetting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingUpdateArgs>(args: SelectSubset<T, SystemSettingUpdateArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSetting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingDeleteManyArgs>(args?: SelectSubset<T, SystemSettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSetting = await prisma.systemSetting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingUpdateManyArgs>(args: SelectSubset<T, SystemSettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemSetting.
     * @param {SystemSettingUpsertArgs} args - Arguments to update or create a SystemSetting.
     * @example
     * // Update or create a SystemSetting
     * const systemSetting = await prisma.systemSetting.upsert({
     *   create: {
     *     // ... data to create a SystemSetting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSetting we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingUpsertArgs>(args: SelectSubset<T, SystemSettingUpsertArgs<ExtArgs>>): Prisma__SystemSettingClient<$Result.GetResult<Prisma.$SystemSettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSetting.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingCountArgs>(
      args?: Subset<T, SystemSettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingAggregateArgs>(args: Subset<T, SystemSettingAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingAggregateType<T>>

    /**
     * Group by SystemSetting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSetting model
   */
  readonly fields: SystemSettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSetting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSetting model
   */
  interface SystemSettingFieldRefs {
    readonly id: FieldRef<"SystemSetting", 'String'>
    readonly key: FieldRef<"SystemSetting", 'String'>
    readonly value: FieldRef<"SystemSetting", 'String'>
    readonly createdAt: FieldRef<"SystemSetting", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemSetting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSetting findUnique
   */
  export type SystemSettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findUniqueOrThrow
   */
  export type SystemSettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting findFirst
   */
  export type SystemSettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findFirstOrThrow
   */
  export type SystemSettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSetting to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting findMany
   */
  export type SystemSettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingOrderByWithRelationInput | SystemSettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingScalarFieldEnum | SystemSettingScalarFieldEnum[]
  }

  /**
   * SystemSetting create
   */
  export type SystemSettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSetting.
     */
    data: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
  }

  /**
   * SystemSetting createMany
   */
  export type SystemSettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingCreateManyInput | SystemSettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSetting update
   */
  export type SystemSettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSetting.
     */
    data: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
    /**
     * Choose, which SystemSetting to update.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting updateMany
   */
  export type SystemSettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingUpdateManyMutationInput, SystemSettingUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSetting upsert
   */
  export type SystemSettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSetting to update in case it exists.
     */
    where: SystemSettingWhereUniqueInput
    /**
     * In case the SystemSetting found by the `where` argument doesn't exist, create a new SystemSetting with this data.
     */
    create: XOR<SystemSettingCreateInput, SystemSettingUncheckedCreateInput>
    /**
     * In case the SystemSetting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingUpdateInput, SystemSettingUncheckedUpdateInput>
  }

  /**
   * SystemSetting delete
   */
  export type SystemSettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
    /**
     * Filter which SystemSetting to delete.
     */
    where: SystemSettingWhereUniqueInput
  }

  /**
   * SystemSetting deleteMany
   */
  export type SystemSettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSetting without action
   */
  export type SystemSettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSetting
     */
    select?: SystemSettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSetting
     */
    omit?: SystemSettingOmit<ExtArgs> | null
  }


  /**
   * Model SearchHistory
   */

  export type AggregateSearchHistory = {
    _count: SearchHistoryCountAggregateOutputType | null
    _avg: SearchHistoryAvgAggregateOutputType | null
    _sum: SearchHistorySumAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  export type SearchHistoryAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    search_count: number | null
    user_id: number | null
    estimated_distance: number | null
    estimated_duration: number | null
    search_completion_rate: number | null
    time_to_result: number | null
    potential_revenue: number | null
    seasonal_factor: number | null
    market_demand_score: number | null
  }

  export type SearchHistorySumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    search_count: number | null
    user_id: number | null
    estimated_distance: number | null
    estimated_duration: number | null
    search_completion_rate: number | null
    time_to_result: number | null
    potential_revenue: number | null
    seasonal_factor: number | null
    market_demand_score: number | null
  }

  export type SearchHistoryMinAggregateOutputType = {
    id: string | null
    search_query: string | null
    latitude: number | null
    longitude: number | null
    search_count: number | null
    first_searched: Date | null
    last_searched: Date | null
    user_type: string | null
    device: string | null
    is_successful: boolean | null
    converted_to_booking: boolean | null
    booking_id: string | null
    user_id: number | null
    session_id: string | null
    source_page: string | null
    search_category: string | null
    estimated_distance: number | null
    estimated_duration: number | null
    peak_hour_search: boolean | null
    region: string | null
    city: string | null
    state: string | null
    search_completion_rate: number | null
    user_agent: string | null
    ip_address: string | null
    referral_source: string | null
    time_to_result: number | null
    competitor_price_check: boolean | null
    potential_revenue: number | null
    seasonal_factor: number | null
    market_demand_score: number | null
  }

  export type SearchHistoryMaxAggregateOutputType = {
    id: string | null
    search_query: string | null
    latitude: number | null
    longitude: number | null
    search_count: number | null
    first_searched: Date | null
    last_searched: Date | null
    user_type: string | null
    device: string | null
    is_successful: boolean | null
    converted_to_booking: boolean | null
    booking_id: string | null
    user_id: number | null
    session_id: string | null
    source_page: string | null
    search_category: string | null
    estimated_distance: number | null
    estimated_duration: number | null
    peak_hour_search: boolean | null
    region: string | null
    city: string | null
    state: string | null
    search_completion_rate: number | null
    user_agent: string | null
    ip_address: string | null
    referral_source: string | null
    time_to_result: number | null
    competitor_price_check: boolean | null
    potential_revenue: number | null
    seasonal_factor: number | null
    market_demand_score: number | null
  }

  export type SearchHistoryCountAggregateOutputType = {
    id: number
    search_query: number
    latitude: number
    longitude: number
    search_count: number
    first_searched: number
    last_searched: number
    user_type: number
    device: number
    is_successful: number
    converted_to_booking: number
    booking_id: number
    user_id: number
    session_id: number
    source_page: number
    search_category: number
    estimated_distance: number
    estimated_duration: number
    peak_hour_search: number
    region: number
    city: number
    state: number
    search_completion_rate: number
    user_agent: number
    ip_address: number
    referral_source: number
    time_to_result: number
    competitor_price_check: number
    potential_revenue: number
    seasonal_factor: number
    market_demand_score: number
    _all: number
  }


  export type SearchHistoryAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    search_count?: true
    user_id?: true
    estimated_distance?: true
    estimated_duration?: true
    search_completion_rate?: true
    time_to_result?: true
    potential_revenue?: true
    seasonal_factor?: true
    market_demand_score?: true
  }

  export type SearchHistorySumAggregateInputType = {
    latitude?: true
    longitude?: true
    search_count?: true
    user_id?: true
    estimated_distance?: true
    estimated_duration?: true
    search_completion_rate?: true
    time_to_result?: true
    potential_revenue?: true
    seasonal_factor?: true
    market_demand_score?: true
  }

  export type SearchHistoryMinAggregateInputType = {
    id?: true
    search_query?: true
    latitude?: true
    longitude?: true
    search_count?: true
    first_searched?: true
    last_searched?: true
    user_type?: true
    device?: true
    is_successful?: true
    converted_to_booking?: true
    booking_id?: true
    user_id?: true
    session_id?: true
    source_page?: true
    search_category?: true
    estimated_distance?: true
    estimated_duration?: true
    peak_hour_search?: true
    region?: true
    city?: true
    state?: true
    search_completion_rate?: true
    user_agent?: true
    ip_address?: true
    referral_source?: true
    time_to_result?: true
    competitor_price_check?: true
    potential_revenue?: true
    seasonal_factor?: true
    market_demand_score?: true
  }

  export type SearchHistoryMaxAggregateInputType = {
    id?: true
    search_query?: true
    latitude?: true
    longitude?: true
    search_count?: true
    first_searched?: true
    last_searched?: true
    user_type?: true
    device?: true
    is_successful?: true
    converted_to_booking?: true
    booking_id?: true
    user_id?: true
    session_id?: true
    source_page?: true
    search_category?: true
    estimated_distance?: true
    estimated_duration?: true
    peak_hour_search?: true
    region?: true
    city?: true
    state?: true
    search_completion_rate?: true
    user_agent?: true
    ip_address?: true
    referral_source?: true
    time_to_result?: true
    competitor_price_check?: true
    potential_revenue?: true
    seasonal_factor?: true
    market_demand_score?: true
  }

  export type SearchHistoryCountAggregateInputType = {
    id?: true
    search_query?: true
    latitude?: true
    longitude?: true
    search_count?: true
    first_searched?: true
    last_searched?: true
    user_type?: true
    device?: true
    is_successful?: true
    converted_to_booking?: true
    booking_id?: true
    user_id?: true
    session_id?: true
    source_page?: true
    search_category?: true
    estimated_distance?: true
    estimated_duration?: true
    peak_hour_search?: true
    region?: true
    city?: true
    state?: true
    search_completion_rate?: true
    user_agent?: true
    ip_address?: true
    referral_source?: true
    time_to_result?: true
    competitor_price_check?: true
    potential_revenue?: true
    seasonal_factor?: true
    market_demand_score?: true
    _all?: true
  }

  export type SearchHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistory to aggregate.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchHistories
    **/
    _count?: true | SearchHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type GetSearchHistoryAggregateType<T extends SearchHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchHistory[P]>
      : GetScalarType<T[P], AggregateSearchHistory[P]>
  }




  export type SearchHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithAggregationInput | SearchHistoryOrderByWithAggregationInput[]
    by: SearchHistoryScalarFieldEnum[] | SearchHistoryScalarFieldEnum
    having?: SearchHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchHistoryCountAggregateInputType | true
    _avg?: SearchHistoryAvgAggregateInputType
    _sum?: SearchHistorySumAggregateInputType
    _min?: SearchHistoryMinAggregateInputType
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type SearchHistoryGroupByOutputType = {
    id: string
    search_query: string
    latitude: number | null
    longitude: number | null
    search_count: number
    first_searched: Date
    last_searched: Date
    user_type: string
    device: string | null
    is_successful: boolean
    converted_to_booking: boolean
    booking_id: string | null
    user_id: number | null
    session_id: string | null
    source_page: string | null
    search_category: string | null
    estimated_distance: number | null
    estimated_duration: number | null
    peak_hour_search: boolean
    region: string | null
    city: string | null
    state: string | null
    search_completion_rate: number | null
    user_agent: string | null
    ip_address: string | null
    referral_source: string | null
    time_to_result: number | null
    competitor_price_check: boolean
    potential_revenue: number | null
    seasonal_factor: number | null
    market_demand_score: number | null
    _count: SearchHistoryCountAggregateOutputType | null
    _avg: SearchHistoryAvgAggregateOutputType | null
    _sum: SearchHistorySumAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  type GetSearchHistoryGroupByPayload<T extends SearchHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SearchHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    search_query?: boolean
    latitude?: boolean
    longitude?: boolean
    search_count?: boolean
    first_searched?: boolean
    last_searched?: boolean
    user_type?: boolean
    device?: boolean
    is_successful?: boolean
    converted_to_booking?: boolean
    booking_id?: boolean
    user_id?: boolean
    session_id?: boolean
    source_page?: boolean
    search_category?: boolean
    estimated_distance?: boolean
    estimated_duration?: boolean
    peak_hour_search?: boolean
    region?: boolean
    city?: boolean
    state?: boolean
    search_completion_rate?: boolean
    user_agent?: boolean
    ip_address?: boolean
    referral_source?: boolean
    time_to_result?: boolean
    competitor_price_check?: boolean
    potential_revenue?: boolean
    seasonal_factor?: boolean
    market_demand_score?: boolean
    user?: boolean | SearchHistory$userArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>



  export type SearchHistorySelectScalar = {
    id?: boolean
    search_query?: boolean
    latitude?: boolean
    longitude?: boolean
    search_count?: boolean
    first_searched?: boolean
    last_searched?: boolean
    user_type?: boolean
    device?: boolean
    is_successful?: boolean
    converted_to_booking?: boolean
    booking_id?: boolean
    user_id?: boolean
    session_id?: boolean
    source_page?: boolean
    search_category?: boolean
    estimated_distance?: boolean
    estimated_duration?: boolean
    peak_hour_search?: boolean
    region?: boolean
    city?: boolean
    state?: boolean
    search_completion_rate?: boolean
    user_agent?: boolean
    ip_address?: boolean
    referral_source?: boolean
    time_to_result?: boolean
    competitor_price_check?: boolean
    potential_revenue?: boolean
    seasonal_factor?: boolean
    market_demand_score?: boolean
  }

  export type SearchHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "search_query" | "latitude" | "longitude" | "search_count" | "first_searched" | "last_searched" | "user_type" | "device" | "is_successful" | "converted_to_booking" | "booking_id" | "user_id" | "session_id" | "source_page" | "search_category" | "estimated_distance" | "estimated_duration" | "peak_hour_search" | "region" | "city" | "state" | "search_completion_rate" | "user_agent" | "ip_address" | "referral_source" | "time_to_result" | "competitor_price_check" | "potential_revenue" | "seasonal_factor" | "market_demand_score", ExtArgs["result"]["searchHistory"]>
  export type SearchHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SearchHistory$userArgs<ExtArgs>
  }

  export type $SearchHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchHistory"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      search_query: string
      latitude: number | null
      longitude: number | null
      search_count: number
      first_searched: Date
      last_searched: Date
      user_type: string
      device: string | null
      is_successful: boolean
      converted_to_booking: boolean
      booking_id: string | null
      user_id: number | null
      session_id: string | null
      source_page: string | null
      search_category: string | null
      estimated_distance: number | null
      estimated_duration: number | null
      peak_hour_search: boolean
      region: string | null
      city: string | null
      state: string | null
      search_completion_rate: number | null
      user_agent: string | null
      ip_address: string | null
      referral_source: string | null
      time_to_result: number | null
      competitor_price_check: boolean
      potential_revenue: number | null
      seasonal_factor: number | null
      market_demand_score: number | null
    }, ExtArgs["result"]["searchHistory"]>
    composites: {}
  }

  type SearchHistoryGetPayload<S extends boolean | null | undefined | SearchHistoryDefaultArgs> = $Result.GetResult<Prisma.$SearchHistoryPayload, S>

  type SearchHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SearchHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SearchHistoryCountAggregateInputType | true
    }

  export interface SearchHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchHistory'], meta: { name: 'SearchHistory' } }
    /**
     * Find zero or one SearchHistory that matches the filter.
     * @param {SearchHistoryFindUniqueArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchHistoryFindUniqueArgs>(args: SelectSubset<T, SearchHistoryFindUniqueArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SearchHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SearchHistoryFindUniqueOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchHistoryFindFirstArgs>(args?: SelectSubset<T, SearchHistoryFindFirstArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SearchHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SearchHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany()
     * 
     * // Get first 10 SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchHistoryFindManyArgs>(args?: SelectSubset<T, SearchHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SearchHistory.
     * @param {SearchHistoryCreateArgs} args - Arguments to create a SearchHistory.
     * @example
     * // Create one SearchHistory
     * const SearchHistory = await prisma.searchHistory.create({
     *   data: {
     *     // ... data to create a SearchHistory
     *   }
     * })
     * 
     */
    create<T extends SearchHistoryCreateArgs>(args: SelectSubset<T, SearchHistoryCreateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SearchHistories.
     * @param {SearchHistoryCreateManyArgs} args - Arguments to create many SearchHistories.
     * @example
     * // Create many SearchHistories
     * const searchHistory = await prisma.searchHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchHistoryCreateManyArgs>(args?: SelectSubset<T, SearchHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SearchHistory.
     * @param {SearchHistoryDeleteArgs} args - Arguments to delete one SearchHistory.
     * @example
     * // Delete one SearchHistory
     * const SearchHistory = await prisma.searchHistory.delete({
     *   where: {
     *     // ... filter to delete one SearchHistory
     *   }
     * })
     * 
     */
    delete<T extends SearchHistoryDeleteArgs>(args: SelectSubset<T, SearchHistoryDeleteArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SearchHistory.
     * @param {SearchHistoryUpdateArgs} args - Arguments to update one SearchHistory.
     * @example
     * // Update one SearchHistory
     * const searchHistory = await prisma.searchHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchHistoryUpdateArgs>(args: SelectSubset<T, SearchHistoryUpdateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SearchHistories.
     * @param {SearchHistoryDeleteManyArgs} args - Arguments to filter SearchHistories to delete.
     * @example
     * // Delete a few SearchHistories
     * const { count } = await prisma.searchHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchHistoryDeleteManyArgs>(args?: SelectSubset<T, SearchHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchHistories
     * const searchHistory = await prisma.searchHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchHistoryUpdateManyArgs>(args: SelectSubset<T, SearchHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SearchHistory.
     * @param {SearchHistoryUpsertArgs} args - Arguments to update or create a SearchHistory.
     * @example
     * // Update or create a SearchHistory
     * const searchHistory = await prisma.searchHistory.upsert({
     *   create: {
     *     // ... data to create a SearchHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchHistory we want to update
     *   }
     * })
     */
    upsert<T extends SearchHistoryUpsertArgs>(args: SelectSubset<T, SearchHistoryUpsertArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryCountArgs} args - Arguments to filter SearchHistories to count.
     * @example
     * // Count the number of SearchHistories
     * const count = await prisma.searchHistory.count({
     *   where: {
     *     // ... the filter for the SearchHistories we want to count
     *   }
     * })
    **/
    count<T extends SearchHistoryCountArgs>(
      args?: Subset<T, SearchHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchHistoryAggregateArgs>(args: Subset<T, SearchHistoryAggregateArgs>): Prisma.PrismaPromise<GetSearchHistoryAggregateType<T>>

    /**
     * Group by SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SearchHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchHistory model
   */
  readonly fields: SearchHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SearchHistory$userArgs<ExtArgs> = {}>(args?: Subset<T, SearchHistory$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchHistory model
   */
  interface SearchHistoryFieldRefs {
    readonly id: FieldRef<"SearchHistory", 'String'>
    readonly search_query: FieldRef<"SearchHistory", 'String'>
    readonly latitude: FieldRef<"SearchHistory", 'Float'>
    readonly longitude: FieldRef<"SearchHistory", 'Float'>
    readonly search_count: FieldRef<"SearchHistory", 'Int'>
    readonly first_searched: FieldRef<"SearchHistory", 'DateTime'>
    readonly last_searched: FieldRef<"SearchHistory", 'DateTime'>
    readonly user_type: FieldRef<"SearchHistory", 'String'>
    readonly device: FieldRef<"SearchHistory", 'String'>
    readonly is_successful: FieldRef<"SearchHistory", 'Boolean'>
    readonly converted_to_booking: FieldRef<"SearchHistory", 'Boolean'>
    readonly booking_id: FieldRef<"SearchHistory", 'String'>
    readonly user_id: FieldRef<"SearchHistory", 'Int'>
    readonly session_id: FieldRef<"SearchHistory", 'String'>
    readonly source_page: FieldRef<"SearchHistory", 'String'>
    readonly search_category: FieldRef<"SearchHistory", 'String'>
    readonly estimated_distance: FieldRef<"SearchHistory", 'Float'>
    readonly estimated_duration: FieldRef<"SearchHistory", 'Int'>
    readonly peak_hour_search: FieldRef<"SearchHistory", 'Boolean'>
    readonly region: FieldRef<"SearchHistory", 'String'>
    readonly city: FieldRef<"SearchHistory", 'String'>
    readonly state: FieldRef<"SearchHistory", 'String'>
    readonly search_completion_rate: FieldRef<"SearchHistory", 'Float'>
    readonly user_agent: FieldRef<"SearchHistory", 'String'>
    readonly ip_address: FieldRef<"SearchHistory", 'String'>
    readonly referral_source: FieldRef<"SearchHistory", 'String'>
    readonly time_to_result: FieldRef<"SearchHistory", 'Int'>
    readonly competitor_price_check: FieldRef<"SearchHistory", 'Boolean'>
    readonly potential_revenue: FieldRef<"SearchHistory", 'Float'>
    readonly seasonal_factor: FieldRef<"SearchHistory", 'Float'>
    readonly market_demand_score: FieldRef<"SearchHistory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SearchHistory findUnique
   */
  export type SearchHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findUniqueOrThrow
   */
  export type SearchHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findFirst
   */
  export type SearchHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findFirstOrThrow
   */
  export type SearchHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findMany
   */
  export type SearchHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistories to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory create
   */
  export type SearchHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchHistory.
     */
    data: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
  }

  /**
   * SearchHistory createMany
   */
  export type SearchHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchHistories.
     */
    data: SearchHistoryCreateManyInput | SearchHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SearchHistory update
   */
  export type SearchHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchHistory.
     */
    data: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
    /**
     * Choose, which SearchHistory to update.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory updateMany
   */
  export type SearchHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchHistories.
     */
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SearchHistories to update
     */
    where?: SearchHistoryWhereInput
    /**
     * Limit how many SearchHistories to update.
     */
    limit?: number
  }

  /**
   * SearchHistory upsert
   */
  export type SearchHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchHistory to update in case it exists.
     */
    where: SearchHistoryWhereUniqueInput
    /**
     * In case the SearchHistory found by the `where` argument doesn't exist, create a new SearchHistory with this data.
     */
    create: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
    /**
     * In case the SearchHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
  }

  /**
   * SearchHistory delete
   */
  export type SearchHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter which SearchHistory to delete.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory deleteMany
   */
  export type SearchHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistories to delete
     */
    where?: SearchHistoryWhereInput
    /**
     * Limit how many SearchHistories to delete.
     */
    limit?: number
  }

  /**
   * SearchHistory.user
   */
  export type SearchHistory$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SearchHistory without action
   */
  export type SearchHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the SearchHistory
     */
    omit?: SearchHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
  }


  /**
   * Model LocationDemandAnalytics
   */

  export type AggregateLocationDemandAnalytics = {
    _count: LocationDemandAnalyticsCountAggregateOutputType | null
    _avg: LocationDemandAnalyticsAvgAggregateOutputType | null
    _sum: LocationDemandAnalyticsSumAggregateOutputType | null
    _min: LocationDemandAnalyticsMinAggregateOutputType | null
    _max: LocationDemandAnalyticsMaxAggregateOutputType | null
  }

  export type LocationDemandAnalyticsAvgAggregateOutputType = {
    total_searches: number | null
    successful_bookings: number | null
    revenue_generated: number | null
    average_fare: number | null
    demand_score: number | null
  }

  export type LocationDemandAnalyticsSumAggregateOutputType = {
    total_searches: number | null
    successful_bookings: number | null
    revenue_generated: number | null
    average_fare: number | null
    demand_score: number | null
  }

  export type LocationDemandAnalyticsMinAggregateOutputType = {
    id: string | null
    region: string | null
    city: string | null
    state: string | null
    total_searches: number | null
    successful_bookings: number | null
    revenue_generated: number | null
    average_fare: number | null
    demand_score: number | null
    updated_at: Date | null
  }

  export type LocationDemandAnalyticsMaxAggregateOutputType = {
    id: string | null
    region: string | null
    city: string | null
    state: string | null
    total_searches: number | null
    successful_bookings: number | null
    revenue_generated: number | null
    average_fare: number | null
    demand_score: number | null
    updated_at: Date | null
  }

  export type LocationDemandAnalyticsCountAggregateOutputType = {
    id: number
    region: number
    city: number
    state: number
    total_searches: number
    successful_bookings: number
    revenue_generated: number
    peak_hours: number
    popular_routes: number
    average_fare: number
    demand_score: number
    updated_at: number
    _all: number
  }


  export type LocationDemandAnalyticsAvgAggregateInputType = {
    total_searches?: true
    successful_bookings?: true
    revenue_generated?: true
    average_fare?: true
    demand_score?: true
  }

  export type LocationDemandAnalyticsSumAggregateInputType = {
    total_searches?: true
    successful_bookings?: true
    revenue_generated?: true
    average_fare?: true
    demand_score?: true
  }

  export type LocationDemandAnalyticsMinAggregateInputType = {
    id?: true
    region?: true
    city?: true
    state?: true
    total_searches?: true
    successful_bookings?: true
    revenue_generated?: true
    average_fare?: true
    demand_score?: true
    updated_at?: true
  }

  export type LocationDemandAnalyticsMaxAggregateInputType = {
    id?: true
    region?: true
    city?: true
    state?: true
    total_searches?: true
    successful_bookings?: true
    revenue_generated?: true
    average_fare?: true
    demand_score?: true
    updated_at?: true
  }

  export type LocationDemandAnalyticsCountAggregateInputType = {
    id?: true
    region?: true
    city?: true
    state?: true
    total_searches?: true
    successful_bookings?: true
    revenue_generated?: true
    peak_hours?: true
    popular_routes?: true
    average_fare?: true
    demand_score?: true
    updated_at?: true
    _all?: true
  }

  export type LocationDemandAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationDemandAnalytics to aggregate.
     */
    where?: LocationDemandAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationDemandAnalytics to fetch.
     */
    orderBy?: LocationDemandAnalyticsOrderByWithRelationInput | LocationDemandAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationDemandAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationDemandAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationDemandAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationDemandAnalytics
    **/
    _count?: true | LocationDemandAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationDemandAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationDemandAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationDemandAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationDemandAnalyticsMaxAggregateInputType
  }

  export type GetLocationDemandAnalyticsAggregateType<T extends LocationDemandAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationDemandAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationDemandAnalytics[P]>
      : GetScalarType<T[P], AggregateLocationDemandAnalytics[P]>
  }




  export type LocationDemandAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationDemandAnalyticsWhereInput
    orderBy?: LocationDemandAnalyticsOrderByWithAggregationInput | LocationDemandAnalyticsOrderByWithAggregationInput[]
    by: LocationDemandAnalyticsScalarFieldEnum[] | LocationDemandAnalyticsScalarFieldEnum
    having?: LocationDemandAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationDemandAnalyticsCountAggregateInputType | true
    _avg?: LocationDemandAnalyticsAvgAggregateInputType
    _sum?: LocationDemandAnalyticsSumAggregateInputType
    _min?: LocationDemandAnalyticsMinAggregateInputType
    _max?: LocationDemandAnalyticsMaxAggregateInputType
  }

  export type LocationDemandAnalyticsGroupByOutputType = {
    id: string
    region: string
    city: string
    state: string
    total_searches: number
    successful_bookings: number
    revenue_generated: number
    peak_hours: JsonValue | null
    popular_routes: JsonValue | null
    average_fare: number | null
    demand_score: number | null
    updated_at: Date
    _count: LocationDemandAnalyticsCountAggregateOutputType | null
    _avg: LocationDemandAnalyticsAvgAggregateOutputType | null
    _sum: LocationDemandAnalyticsSumAggregateOutputType | null
    _min: LocationDemandAnalyticsMinAggregateOutputType | null
    _max: LocationDemandAnalyticsMaxAggregateOutputType | null
  }

  type GetLocationDemandAnalyticsGroupByPayload<T extends LocationDemandAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationDemandAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationDemandAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationDemandAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], LocationDemandAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type LocationDemandAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    region?: boolean
    city?: boolean
    state?: boolean
    total_searches?: boolean
    successful_bookings?: boolean
    revenue_generated?: boolean
    peak_hours?: boolean
    popular_routes?: boolean
    average_fare?: boolean
    demand_score?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["locationDemandAnalytics"]>



  export type LocationDemandAnalyticsSelectScalar = {
    id?: boolean
    region?: boolean
    city?: boolean
    state?: boolean
    total_searches?: boolean
    successful_bookings?: boolean
    revenue_generated?: boolean
    peak_hours?: boolean
    popular_routes?: boolean
    average_fare?: boolean
    demand_score?: boolean
    updated_at?: boolean
  }

  export type LocationDemandAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "region" | "city" | "state" | "total_searches" | "successful_bookings" | "revenue_generated" | "peak_hours" | "popular_routes" | "average_fare" | "demand_score" | "updated_at", ExtArgs["result"]["locationDemandAnalytics"]>

  export type $LocationDemandAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationDemandAnalytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      region: string
      city: string
      state: string
      total_searches: number
      successful_bookings: number
      revenue_generated: number
      peak_hours: Prisma.JsonValue | null
      popular_routes: Prisma.JsonValue | null
      average_fare: number | null
      demand_score: number | null
      updated_at: Date
    }, ExtArgs["result"]["locationDemandAnalytics"]>
    composites: {}
  }

  type LocationDemandAnalyticsGetPayload<S extends boolean | null | undefined | LocationDemandAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$LocationDemandAnalyticsPayload, S>

  type LocationDemandAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationDemandAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationDemandAnalyticsCountAggregateInputType | true
    }

  export interface LocationDemandAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationDemandAnalytics'], meta: { name: 'LocationDemandAnalytics' } }
    /**
     * Find zero or one LocationDemandAnalytics that matches the filter.
     * @param {LocationDemandAnalyticsFindUniqueArgs} args - Arguments to find a LocationDemandAnalytics
     * @example
     * // Get one LocationDemandAnalytics
     * const locationDemandAnalytics = await prisma.locationDemandAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationDemandAnalyticsFindUniqueArgs>(args: SelectSubset<T, LocationDemandAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__LocationDemandAnalyticsClient<$Result.GetResult<Prisma.$LocationDemandAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocationDemandAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationDemandAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a LocationDemandAnalytics
     * @example
     * // Get one LocationDemandAnalytics
     * const locationDemandAnalytics = await prisma.locationDemandAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationDemandAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationDemandAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationDemandAnalyticsClient<$Result.GetResult<Prisma.$LocationDemandAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationDemandAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDemandAnalyticsFindFirstArgs} args - Arguments to find a LocationDemandAnalytics
     * @example
     * // Get one LocationDemandAnalytics
     * const locationDemandAnalytics = await prisma.locationDemandAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationDemandAnalyticsFindFirstArgs>(args?: SelectSubset<T, LocationDemandAnalyticsFindFirstArgs<ExtArgs>>): Prisma__LocationDemandAnalyticsClient<$Result.GetResult<Prisma.$LocationDemandAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationDemandAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDemandAnalyticsFindFirstOrThrowArgs} args - Arguments to find a LocationDemandAnalytics
     * @example
     * // Get one LocationDemandAnalytics
     * const locationDemandAnalytics = await prisma.locationDemandAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationDemandAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationDemandAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationDemandAnalyticsClient<$Result.GetResult<Prisma.$LocationDemandAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocationDemandAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDemandAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationDemandAnalytics
     * const locationDemandAnalytics = await prisma.locationDemandAnalytics.findMany()
     * 
     * // Get first 10 LocationDemandAnalytics
     * const locationDemandAnalytics = await prisma.locationDemandAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationDemandAnalyticsWithIdOnly = await prisma.locationDemandAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationDemandAnalyticsFindManyArgs>(args?: SelectSubset<T, LocationDemandAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationDemandAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocationDemandAnalytics.
     * @param {LocationDemandAnalyticsCreateArgs} args - Arguments to create a LocationDemandAnalytics.
     * @example
     * // Create one LocationDemandAnalytics
     * const LocationDemandAnalytics = await prisma.locationDemandAnalytics.create({
     *   data: {
     *     // ... data to create a LocationDemandAnalytics
     *   }
     * })
     * 
     */
    create<T extends LocationDemandAnalyticsCreateArgs>(args: SelectSubset<T, LocationDemandAnalyticsCreateArgs<ExtArgs>>): Prisma__LocationDemandAnalyticsClient<$Result.GetResult<Prisma.$LocationDemandAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocationDemandAnalytics.
     * @param {LocationDemandAnalyticsCreateManyArgs} args - Arguments to create many LocationDemandAnalytics.
     * @example
     * // Create many LocationDemandAnalytics
     * const locationDemandAnalytics = await prisma.locationDemandAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationDemandAnalyticsCreateManyArgs>(args?: SelectSubset<T, LocationDemandAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LocationDemandAnalytics.
     * @param {LocationDemandAnalyticsDeleteArgs} args - Arguments to delete one LocationDemandAnalytics.
     * @example
     * // Delete one LocationDemandAnalytics
     * const LocationDemandAnalytics = await prisma.locationDemandAnalytics.delete({
     *   where: {
     *     // ... filter to delete one LocationDemandAnalytics
     *   }
     * })
     * 
     */
    delete<T extends LocationDemandAnalyticsDeleteArgs>(args: SelectSubset<T, LocationDemandAnalyticsDeleteArgs<ExtArgs>>): Prisma__LocationDemandAnalyticsClient<$Result.GetResult<Prisma.$LocationDemandAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocationDemandAnalytics.
     * @param {LocationDemandAnalyticsUpdateArgs} args - Arguments to update one LocationDemandAnalytics.
     * @example
     * // Update one LocationDemandAnalytics
     * const locationDemandAnalytics = await prisma.locationDemandAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationDemandAnalyticsUpdateArgs>(args: SelectSubset<T, LocationDemandAnalyticsUpdateArgs<ExtArgs>>): Prisma__LocationDemandAnalyticsClient<$Result.GetResult<Prisma.$LocationDemandAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocationDemandAnalytics.
     * @param {LocationDemandAnalyticsDeleteManyArgs} args - Arguments to filter LocationDemandAnalytics to delete.
     * @example
     * // Delete a few LocationDemandAnalytics
     * const { count } = await prisma.locationDemandAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDemandAnalyticsDeleteManyArgs>(args?: SelectSubset<T, LocationDemandAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationDemandAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDemandAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationDemandAnalytics
     * const locationDemandAnalytics = await prisma.locationDemandAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationDemandAnalyticsUpdateManyArgs>(args: SelectSubset<T, LocationDemandAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LocationDemandAnalytics.
     * @param {LocationDemandAnalyticsUpsertArgs} args - Arguments to update or create a LocationDemandAnalytics.
     * @example
     * // Update or create a LocationDemandAnalytics
     * const locationDemandAnalytics = await prisma.locationDemandAnalytics.upsert({
     *   create: {
     *     // ... data to create a LocationDemandAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationDemandAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends LocationDemandAnalyticsUpsertArgs>(args: SelectSubset<T, LocationDemandAnalyticsUpsertArgs<ExtArgs>>): Prisma__LocationDemandAnalyticsClient<$Result.GetResult<Prisma.$LocationDemandAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LocationDemandAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDemandAnalyticsCountArgs} args - Arguments to filter LocationDemandAnalytics to count.
     * @example
     * // Count the number of LocationDemandAnalytics
     * const count = await prisma.locationDemandAnalytics.count({
     *   where: {
     *     // ... the filter for the LocationDemandAnalytics we want to count
     *   }
     * })
    **/
    count<T extends LocationDemandAnalyticsCountArgs>(
      args?: Subset<T, LocationDemandAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationDemandAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationDemandAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDemandAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationDemandAnalyticsAggregateArgs>(args: Subset<T, LocationDemandAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetLocationDemandAnalyticsAggregateType<T>>

    /**
     * Group by LocationDemandAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationDemandAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationDemandAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationDemandAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: LocationDemandAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationDemandAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationDemandAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationDemandAnalytics model
   */
  readonly fields: LocationDemandAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationDemandAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationDemandAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationDemandAnalytics model
   */
  interface LocationDemandAnalyticsFieldRefs {
    readonly id: FieldRef<"LocationDemandAnalytics", 'String'>
    readonly region: FieldRef<"LocationDemandAnalytics", 'String'>
    readonly city: FieldRef<"LocationDemandAnalytics", 'String'>
    readonly state: FieldRef<"LocationDemandAnalytics", 'String'>
    readonly total_searches: FieldRef<"LocationDemandAnalytics", 'Int'>
    readonly successful_bookings: FieldRef<"LocationDemandAnalytics", 'Int'>
    readonly revenue_generated: FieldRef<"LocationDemandAnalytics", 'Float'>
    readonly peak_hours: FieldRef<"LocationDemandAnalytics", 'Json'>
    readonly popular_routes: FieldRef<"LocationDemandAnalytics", 'Json'>
    readonly average_fare: FieldRef<"LocationDemandAnalytics", 'Float'>
    readonly demand_score: FieldRef<"LocationDemandAnalytics", 'Int'>
    readonly updated_at: FieldRef<"LocationDemandAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocationDemandAnalytics findUnique
   */
  export type LocationDemandAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDemandAnalytics
     */
    select?: LocationDemandAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationDemandAnalytics
     */
    omit?: LocationDemandAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which LocationDemandAnalytics to fetch.
     */
    where: LocationDemandAnalyticsWhereUniqueInput
  }

  /**
   * LocationDemandAnalytics findUniqueOrThrow
   */
  export type LocationDemandAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDemandAnalytics
     */
    select?: LocationDemandAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationDemandAnalytics
     */
    omit?: LocationDemandAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which LocationDemandAnalytics to fetch.
     */
    where: LocationDemandAnalyticsWhereUniqueInput
  }

  /**
   * LocationDemandAnalytics findFirst
   */
  export type LocationDemandAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDemandAnalytics
     */
    select?: LocationDemandAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationDemandAnalytics
     */
    omit?: LocationDemandAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which LocationDemandAnalytics to fetch.
     */
    where?: LocationDemandAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationDemandAnalytics to fetch.
     */
    orderBy?: LocationDemandAnalyticsOrderByWithRelationInput | LocationDemandAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationDemandAnalytics.
     */
    cursor?: LocationDemandAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationDemandAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationDemandAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationDemandAnalytics.
     */
    distinct?: LocationDemandAnalyticsScalarFieldEnum | LocationDemandAnalyticsScalarFieldEnum[]
  }

  /**
   * LocationDemandAnalytics findFirstOrThrow
   */
  export type LocationDemandAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDemandAnalytics
     */
    select?: LocationDemandAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationDemandAnalytics
     */
    omit?: LocationDemandAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which LocationDemandAnalytics to fetch.
     */
    where?: LocationDemandAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationDemandAnalytics to fetch.
     */
    orderBy?: LocationDemandAnalyticsOrderByWithRelationInput | LocationDemandAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationDemandAnalytics.
     */
    cursor?: LocationDemandAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationDemandAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationDemandAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationDemandAnalytics.
     */
    distinct?: LocationDemandAnalyticsScalarFieldEnum | LocationDemandAnalyticsScalarFieldEnum[]
  }

  /**
   * LocationDemandAnalytics findMany
   */
  export type LocationDemandAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDemandAnalytics
     */
    select?: LocationDemandAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationDemandAnalytics
     */
    omit?: LocationDemandAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which LocationDemandAnalytics to fetch.
     */
    where?: LocationDemandAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationDemandAnalytics to fetch.
     */
    orderBy?: LocationDemandAnalyticsOrderByWithRelationInput | LocationDemandAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationDemandAnalytics.
     */
    cursor?: LocationDemandAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationDemandAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationDemandAnalytics.
     */
    skip?: number
    distinct?: LocationDemandAnalyticsScalarFieldEnum | LocationDemandAnalyticsScalarFieldEnum[]
  }

  /**
   * LocationDemandAnalytics create
   */
  export type LocationDemandAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDemandAnalytics
     */
    select?: LocationDemandAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationDemandAnalytics
     */
    omit?: LocationDemandAnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to create a LocationDemandAnalytics.
     */
    data: XOR<LocationDemandAnalyticsCreateInput, LocationDemandAnalyticsUncheckedCreateInput>
  }

  /**
   * LocationDemandAnalytics createMany
   */
  export type LocationDemandAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationDemandAnalytics.
     */
    data: LocationDemandAnalyticsCreateManyInput | LocationDemandAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LocationDemandAnalytics update
   */
  export type LocationDemandAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDemandAnalytics
     */
    select?: LocationDemandAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationDemandAnalytics
     */
    omit?: LocationDemandAnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to update a LocationDemandAnalytics.
     */
    data: XOR<LocationDemandAnalyticsUpdateInput, LocationDemandAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which LocationDemandAnalytics to update.
     */
    where: LocationDemandAnalyticsWhereUniqueInput
  }

  /**
   * LocationDemandAnalytics updateMany
   */
  export type LocationDemandAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationDemandAnalytics.
     */
    data: XOR<LocationDemandAnalyticsUpdateManyMutationInput, LocationDemandAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which LocationDemandAnalytics to update
     */
    where?: LocationDemandAnalyticsWhereInput
    /**
     * Limit how many LocationDemandAnalytics to update.
     */
    limit?: number
  }

  /**
   * LocationDemandAnalytics upsert
   */
  export type LocationDemandAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDemandAnalytics
     */
    select?: LocationDemandAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationDemandAnalytics
     */
    omit?: LocationDemandAnalyticsOmit<ExtArgs> | null
    /**
     * The filter to search for the LocationDemandAnalytics to update in case it exists.
     */
    where: LocationDemandAnalyticsWhereUniqueInput
    /**
     * In case the LocationDemandAnalytics found by the `where` argument doesn't exist, create a new LocationDemandAnalytics with this data.
     */
    create: XOR<LocationDemandAnalyticsCreateInput, LocationDemandAnalyticsUncheckedCreateInput>
    /**
     * In case the LocationDemandAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationDemandAnalyticsUpdateInput, LocationDemandAnalyticsUncheckedUpdateInput>
  }

  /**
   * LocationDemandAnalytics delete
   */
  export type LocationDemandAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDemandAnalytics
     */
    select?: LocationDemandAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationDemandAnalytics
     */
    omit?: LocationDemandAnalyticsOmit<ExtArgs> | null
    /**
     * Filter which LocationDemandAnalytics to delete.
     */
    where: LocationDemandAnalyticsWhereUniqueInput
  }

  /**
   * LocationDemandAnalytics deleteMany
   */
  export type LocationDemandAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationDemandAnalytics to delete
     */
    where?: LocationDemandAnalyticsWhereInput
    /**
     * Limit how many LocationDemandAnalytics to delete.
     */
    limit?: number
  }

  /**
   * LocationDemandAnalytics without action
   */
  export type LocationDemandAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationDemandAnalytics
     */
    select?: LocationDemandAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationDemandAnalytics
     */
    omit?: LocationDemandAnalyticsOmit<ExtArgs> | null
  }


  /**
   * Model PricingAnalytics
   */

  export type AggregatePricingAnalytics = {
    _count: PricingAnalyticsCountAggregateOutputType | null
    _avg: PricingAnalyticsAvgAggregateOutputType | null
    _sum: PricingAnalyticsSumAggregateOutputType | null
    _min: PricingAnalyticsMinAggregateOutputType | null
    _max: PricingAnalyticsMaxAggregateOutputType | null
  }

  export type PricingAnalyticsAvgAggregateOutputType = {
    base_price: number | null
    surge_multiplier: number | null
    peak_hour_rate: number | null
    off_peak_rate: number | null
    competitor_price: number | null
    success_rate: number | null
  }

  export type PricingAnalyticsSumAggregateOutputType = {
    base_price: number | null
    surge_multiplier: number | null
    peak_hour_rate: number | null
    off_peak_rate: number | null
    competitor_price: number | null
    success_rate: number | null
  }

  export type PricingAnalyticsMinAggregateOutputType = {
    id: string | null
    route_hash: string | null
    base_price: number | null
    surge_multiplier: number | null
    peak_hour_rate: number | null
    off_peak_rate: number | null
    competitor_price: number | null
    success_rate: number | null
    last_updated: Date | null
  }

  export type PricingAnalyticsMaxAggregateOutputType = {
    id: string | null
    route_hash: string | null
    base_price: number | null
    surge_multiplier: number | null
    peak_hour_rate: number | null
    off_peak_rate: number | null
    competitor_price: number | null
    success_rate: number | null
    last_updated: Date | null
  }

  export type PricingAnalyticsCountAggregateOutputType = {
    id: number
    route_hash: number
    base_price: number
    surge_multiplier: number
    peak_hour_rate: number
    off_peak_rate: number
    competitor_price: number
    success_rate: number
    last_updated: number
    _all: number
  }


  export type PricingAnalyticsAvgAggregateInputType = {
    base_price?: true
    surge_multiplier?: true
    peak_hour_rate?: true
    off_peak_rate?: true
    competitor_price?: true
    success_rate?: true
  }

  export type PricingAnalyticsSumAggregateInputType = {
    base_price?: true
    surge_multiplier?: true
    peak_hour_rate?: true
    off_peak_rate?: true
    competitor_price?: true
    success_rate?: true
  }

  export type PricingAnalyticsMinAggregateInputType = {
    id?: true
    route_hash?: true
    base_price?: true
    surge_multiplier?: true
    peak_hour_rate?: true
    off_peak_rate?: true
    competitor_price?: true
    success_rate?: true
    last_updated?: true
  }

  export type PricingAnalyticsMaxAggregateInputType = {
    id?: true
    route_hash?: true
    base_price?: true
    surge_multiplier?: true
    peak_hour_rate?: true
    off_peak_rate?: true
    competitor_price?: true
    success_rate?: true
    last_updated?: true
  }

  export type PricingAnalyticsCountAggregateInputType = {
    id?: true
    route_hash?: true
    base_price?: true
    surge_multiplier?: true
    peak_hour_rate?: true
    off_peak_rate?: true
    competitor_price?: true
    success_rate?: true
    last_updated?: true
    _all?: true
  }

  export type PricingAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingAnalytics to aggregate.
     */
    where?: PricingAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingAnalytics to fetch.
     */
    orderBy?: PricingAnalyticsOrderByWithRelationInput | PricingAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PricingAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PricingAnalytics
    **/
    _count?: true | PricingAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PricingAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PricingAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PricingAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PricingAnalyticsMaxAggregateInputType
  }

  export type GetPricingAnalyticsAggregateType<T extends PricingAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregatePricingAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePricingAnalytics[P]>
      : GetScalarType<T[P], AggregatePricingAnalytics[P]>
  }




  export type PricingAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PricingAnalyticsWhereInput
    orderBy?: PricingAnalyticsOrderByWithAggregationInput | PricingAnalyticsOrderByWithAggregationInput[]
    by: PricingAnalyticsScalarFieldEnum[] | PricingAnalyticsScalarFieldEnum
    having?: PricingAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PricingAnalyticsCountAggregateInputType | true
    _avg?: PricingAnalyticsAvgAggregateInputType
    _sum?: PricingAnalyticsSumAggregateInputType
    _min?: PricingAnalyticsMinAggregateInputType
    _max?: PricingAnalyticsMaxAggregateInputType
  }

  export type PricingAnalyticsGroupByOutputType = {
    id: string
    route_hash: string
    base_price: number
    surge_multiplier: number
    peak_hour_rate: number | null
    off_peak_rate: number | null
    competitor_price: number | null
    success_rate: number | null
    last_updated: Date
    _count: PricingAnalyticsCountAggregateOutputType | null
    _avg: PricingAnalyticsAvgAggregateOutputType | null
    _sum: PricingAnalyticsSumAggregateOutputType | null
    _min: PricingAnalyticsMinAggregateOutputType | null
    _max: PricingAnalyticsMaxAggregateOutputType | null
  }

  type GetPricingAnalyticsGroupByPayload<T extends PricingAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PricingAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PricingAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PricingAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], PricingAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type PricingAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    route_hash?: boolean
    base_price?: boolean
    surge_multiplier?: boolean
    peak_hour_rate?: boolean
    off_peak_rate?: boolean
    competitor_price?: boolean
    success_rate?: boolean
    last_updated?: boolean
  }, ExtArgs["result"]["pricingAnalytics"]>



  export type PricingAnalyticsSelectScalar = {
    id?: boolean
    route_hash?: boolean
    base_price?: boolean
    surge_multiplier?: boolean
    peak_hour_rate?: boolean
    off_peak_rate?: boolean
    competitor_price?: boolean
    success_rate?: boolean
    last_updated?: boolean
  }

  export type PricingAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "route_hash" | "base_price" | "surge_multiplier" | "peak_hour_rate" | "off_peak_rate" | "competitor_price" | "success_rate" | "last_updated", ExtArgs["result"]["pricingAnalytics"]>

  export type $PricingAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PricingAnalytics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      route_hash: string
      base_price: number
      surge_multiplier: number
      peak_hour_rate: number | null
      off_peak_rate: number | null
      competitor_price: number | null
      success_rate: number | null
      last_updated: Date
    }, ExtArgs["result"]["pricingAnalytics"]>
    composites: {}
  }

  type PricingAnalyticsGetPayload<S extends boolean | null | undefined | PricingAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$PricingAnalyticsPayload, S>

  type PricingAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PricingAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PricingAnalyticsCountAggregateInputType | true
    }

  export interface PricingAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PricingAnalytics'], meta: { name: 'PricingAnalytics' } }
    /**
     * Find zero or one PricingAnalytics that matches the filter.
     * @param {PricingAnalyticsFindUniqueArgs} args - Arguments to find a PricingAnalytics
     * @example
     * // Get one PricingAnalytics
     * const pricingAnalytics = await prisma.pricingAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PricingAnalyticsFindUniqueArgs>(args: SelectSubset<T, PricingAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__PricingAnalyticsClient<$Result.GetResult<Prisma.$PricingAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PricingAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PricingAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a PricingAnalytics
     * @example
     * // Get one PricingAnalytics
     * const pricingAnalytics = await prisma.pricingAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PricingAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, PricingAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PricingAnalyticsClient<$Result.GetResult<Prisma.$PricingAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PricingAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingAnalyticsFindFirstArgs} args - Arguments to find a PricingAnalytics
     * @example
     * // Get one PricingAnalytics
     * const pricingAnalytics = await prisma.pricingAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PricingAnalyticsFindFirstArgs>(args?: SelectSubset<T, PricingAnalyticsFindFirstArgs<ExtArgs>>): Prisma__PricingAnalyticsClient<$Result.GetResult<Prisma.$PricingAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PricingAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingAnalyticsFindFirstOrThrowArgs} args - Arguments to find a PricingAnalytics
     * @example
     * // Get one PricingAnalytics
     * const pricingAnalytics = await prisma.pricingAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PricingAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, PricingAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PricingAnalyticsClient<$Result.GetResult<Prisma.$PricingAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PricingAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PricingAnalytics
     * const pricingAnalytics = await prisma.pricingAnalytics.findMany()
     * 
     * // Get first 10 PricingAnalytics
     * const pricingAnalytics = await prisma.pricingAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pricingAnalyticsWithIdOnly = await prisma.pricingAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PricingAnalyticsFindManyArgs>(args?: SelectSubset<T, PricingAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PricingAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PricingAnalytics.
     * @param {PricingAnalyticsCreateArgs} args - Arguments to create a PricingAnalytics.
     * @example
     * // Create one PricingAnalytics
     * const PricingAnalytics = await prisma.pricingAnalytics.create({
     *   data: {
     *     // ... data to create a PricingAnalytics
     *   }
     * })
     * 
     */
    create<T extends PricingAnalyticsCreateArgs>(args: SelectSubset<T, PricingAnalyticsCreateArgs<ExtArgs>>): Prisma__PricingAnalyticsClient<$Result.GetResult<Prisma.$PricingAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PricingAnalytics.
     * @param {PricingAnalyticsCreateManyArgs} args - Arguments to create many PricingAnalytics.
     * @example
     * // Create many PricingAnalytics
     * const pricingAnalytics = await prisma.pricingAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PricingAnalyticsCreateManyArgs>(args?: SelectSubset<T, PricingAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PricingAnalytics.
     * @param {PricingAnalyticsDeleteArgs} args - Arguments to delete one PricingAnalytics.
     * @example
     * // Delete one PricingAnalytics
     * const PricingAnalytics = await prisma.pricingAnalytics.delete({
     *   where: {
     *     // ... filter to delete one PricingAnalytics
     *   }
     * })
     * 
     */
    delete<T extends PricingAnalyticsDeleteArgs>(args: SelectSubset<T, PricingAnalyticsDeleteArgs<ExtArgs>>): Prisma__PricingAnalyticsClient<$Result.GetResult<Prisma.$PricingAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PricingAnalytics.
     * @param {PricingAnalyticsUpdateArgs} args - Arguments to update one PricingAnalytics.
     * @example
     * // Update one PricingAnalytics
     * const pricingAnalytics = await prisma.pricingAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PricingAnalyticsUpdateArgs>(args: SelectSubset<T, PricingAnalyticsUpdateArgs<ExtArgs>>): Prisma__PricingAnalyticsClient<$Result.GetResult<Prisma.$PricingAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PricingAnalytics.
     * @param {PricingAnalyticsDeleteManyArgs} args - Arguments to filter PricingAnalytics to delete.
     * @example
     * // Delete a few PricingAnalytics
     * const { count } = await prisma.pricingAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PricingAnalyticsDeleteManyArgs>(args?: SelectSubset<T, PricingAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PricingAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PricingAnalytics
     * const pricingAnalytics = await prisma.pricingAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PricingAnalyticsUpdateManyArgs>(args: SelectSubset<T, PricingAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PricingAnalytics.
     * @param {PricingAnalyticsUpsertArgs} args - Arguments to update or create a PricingAnalytics.
     * @example
     * // Update or create a PricingAnalytics
     * const pricingAnalytics = await prisma.pricingAnalytics.upsert({
     *   create: {
     *     // ... data to create a PricingAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PricingAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends PricingAnalyticsUpsertArgs>(args: SelectSubset<T, PricingAnalyticsUpsertArgs<ExtArgs>>): Prisma__PricingAnalyticsClient<$Result.GetResult<Prisma.$PricingAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PricingAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingAnalyticsCountArgs} args - Arguments to filter PricingAnalytics to count.
     * @example
     * // Count the number of PricingAnalytics
     * const count = await prisma.pricingAnalytics.count({
     *   where: {
     *     // ... the filter for the PricingAnalytics we want to count
     *   }
     * })
    **/
    count<T extends PricingAnalyticsCountArgs>(
      args?: Subset<T, PricingAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PricingAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PricingAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PricingAnalyticsAggregateArgs>(args: Subset<T, PricingAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetPricingAnalyticsAggregateType<T>>

    /**
     * Group by PricingAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PricingAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PricingAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PricingAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: PricingAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PricingAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPricingAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PricingAnalytics model
   */
  readonly fields: PricingAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PricingAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PricingAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PricingAnalytics model
   */
  interface PricingAnalyticsFieldRefs {
    readonly id: FieldRef<"PricingAnalytics", 'String'>
    readonly route_hash: FieldRef<"PricingAnalytics", 'String'>
    readonly base_price: FieldRef<"PricingAnalytics", 'Float'>
    readonly surge_multiplier: FieldRef<"PricingAnalytics", 'Float'>
    readonly peak_hour_rate: FieldRef<"PricingAnalytics", 'Float'>
    readonly off_peak_rate: FieldRef<"PricingAnalytics", 'Float'>
    readonly competitor_price: FieldRef<"PricingAnalytics", 'Float'>
    readonly success_rate: FieldRef<"PricingAnalytics", 'Float'>
    readonly last_updated: FieldRef<"PricingAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PricingAnalytics findUnique
   */
  export type PricingAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingAnalytics
     */
    select?: PricingAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingAnalytics
     */
    omit?: PricingAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which PricingAnalytics to fetch.
     */
    where: PricingAnalyticsWhereUniqueInput
  }

  /**
   * PricingAnalytics findUniqueOrThrow
   */
  export type PricingAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingAnalytics
     */
    select?: PricingAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingAnalytics
     */
    omit?: PricingAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which PricingAnalytics to fetch.
     */
    where: PricingAnalyticsWhereUniqueInput
  }

  /**
   * PricingAnalytics findFirst
   */
  export type PricingAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingAnalytics
     */
    select?: PricingAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingAnalytics
     */
    omit?: PricingAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which PricingAnalytics to fetch.
     */
    where?: PricingAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingAnalytics to fetch.
     */
    orderBy?: PricingAnalyticsOrderByWithRelationInput | PricingAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingAnalytics.
     */
    cursor?: PricingAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingAnalytics.
     */
    distinct?: PricingAnalyticsScalarFieldEnum | PricingAnalyticsScalarFieldEnum[]
  }

  /**
   * PricingAnalytics findFirstOrThrow
   */
  export type PricingAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingAnalytics
     */
    select?: PricingAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingAnalytics
     */
    omit?: PricingAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which PricingAnalytics to fetch.
     */
    where?: PricingAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingAnalytics to fetch.
     */
    orderBy?: PricingAnalyticsOrderByWithRelationInput | PricingAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PricingAnalytics.
     */
    cursor?: PricingAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PricingAnalytics.
     */
    distinct?: PricingAnalyticsScalarFieldEnum | PricingAnalyticsScalarFieldEnum[]
  }

  /**
   * PricingAnalytics findMany
   */
  export type PricingAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingAnalytics
     */
    select?: PricingAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingAnalytics
     */
    omit?: PricingAnalyticsOmit<ExtArgs> | null
    /**
     * Filter, which PricingAnalytics to fetch.
     */
    where?: PricingAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PricingAnalytics to fetch.
     */
    orderBy?: PricingAnalyticsOrderByWithRelationInput | PricingAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PricingAnalytics.
     */
    cursor?: PricingAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PricingAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PricingAnalytics.
     */
    skip?: number
    distinct?: PricingAnalyticsScalarFieldEnum | PricingAnalyticsScalarFieldEnum[]
  }

  /**
   * PricingAnalytics create
   */
  export type PricingAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingAnalytics
     */
    select?: PricingAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingAnalytics
     */
    omit?: PricingAnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to create a PricingAnalytics.
     */
    data: XOR<PricingAnalyticsCreateInput, PricingAnalyticsUncheckedCreateInput>
  }

  /**
   * PricingAnalytics createMany
   */
  export type PricingAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PricingAnalytics.
     */
    data: PricingAnalyticsCreateManyInput | PricingAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PricingAnalytics update
   */
  export type PricingAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingAnalytics
     */
    select?: PricingAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingAnalytics
     */
    omit?: PricingAnalyticsOmit<ExtArgs> | null
    /**
     * The data needed to update a PricingAnalytics.
     */
    data: XOR<PricingAnalyticsUpdateInput, PricingAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which PricingAnalytics to update.
     */
    where: PricingAnalyticsWhereUniqueInput
  }

  /**
   * PricingAnalytics updateMany
   */
  export type PricingAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PricingAnalytics.
     */
    data: XOR<PricingAnalyticsUpdateManyMutationInput, PricingAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which PricingAnalytics to update
     */
    where?: PricingAnalyticsWhereInput
    /**
     * Limit how many PricingAnalytics to update.
     */
    limit?: number
  }

  /**
   * PricingAnalytics upsert
   */
  export type PricingAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingAnalytics
     */
    select?: PricingAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingAnalytics
     */
    omit?: PricingAnalyticsOmit<ExtArgs> | null
    /**
     * The filter to search for the PricingAnalytics to update in case it exists.
     */
    where: PricingAnalyticsWhereUniqueInput
    /**
     * In case the PricingAnalytics found by the `where` argument doesn't exist, create a new PricingAnalytics with this data.
     */
    create: XOR<PricingAnalyticsCreateInput, PricingAnalyticsUncheckedCreateInput>
    /**
     * In case the PricingAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PricingAnalyticsUpdateInput, PricingAnalyticsUncheckedUpdateInput>
  }

  /**
   * PricingAnalytics delete
   */
  export type PricingAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingAnalytics
     */
    select?: PricingAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingAnalytics
     */
    omit?: PricingAnalyticsOmit<ExtArgs> | null
    /**
     * Filter which PricingAnalytics to delete.
     */
    where: PricingAnalyticsWhereUniqueInput
  }

  /**
   * PricingAnalytics deleteMany
   */
  export type PricingAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PricingAnalytics to delete
     */
    where?: PricingAnalyticsWhereInput
    /**
     * Limit how many PricingAnalytics to delete.
     */
    limit?: number
  }

  /**
   * PricingAnalytics without action
   */
  export type PricingAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PricingAnalytics
     */
    select?: PricingAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PricingAnalytics
     */
    omit?: PricingAnalyticsOmit<ExtArgs> | null
  }


  /**
   * Model Location
   */

  export type AggregateLocation = {
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  export type LocationMinAggregateOutputType = {
    id: string | null
    name: string | null
    district: string | null
    state: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationMaxAggregateOutputType = {
    id: string | null
    name: string | null
    district: string | null
    state: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LocationCountAggregateOutputType = {
    id: number
    name: number
    district: number
    state: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LocationMinAggregateInputType = {
    id?: true
    name?: true
    district?: true
    state?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationMaxAggregateInputType = {
    id?: true
    name?: true
    district?: true
    state?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LocationCountAggregateInputType = {
    id?: true
    name?: true
    district?: true
    state?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Location to aggregate.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Locations
    **/
    _count?: true | LocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationMaxAggregateInputType
  }

  export type GetLocationAggregateType<T extends LocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocation[P]>
      : GetScalarType<T[P], AggregateLocation[P]>
  }




  export type LocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationWhereInput
    orderBy?: LocationOrderByWithAggregationInput | LocationOrderByWithAggregationInput[]
    by: LocationScalarFieldEnum[] | LocationScalarFieldEnum
    having?: LocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationCountAggregateInputType | true
    _min?: LocationMinAggregateInputType
    _max?: LocationMaxAggregateInputType
  }

  export type LocationGroupByOutputType = {
    id: string
    name: string
    district: string
    state: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: LocationCountAggregateOutputType | null
    _min: LocationMinAggregateOutputType | null
    _max: LocationMaxAggregateOutputType | null
  }

  type GetLocationGroupByPayload<T extends LocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationGroupByOutputType[P]>
            : GetScalarType<T[P], LocationGroupByOutputType[P]>
        }
      >
    >


  export type LocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    district?: boolean
    state?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    routesFrom?: boolean | Location$routesFromArgs<ExtArgs>
    routesTo?: boolean | Location$routesToArgs<ExtArgs>
    stops?: boolean | Location$stopsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["location"]>



  export type LocationSelectScalar = {
    id?: boolean
    name?: boolean
    district?: boolean
    state?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "district" | "state" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["location"]>
  export type LocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routesFrom?: boolean | Location$routesFromArgs<ExtArgs>
    routesTo?: boolean | Location$routesToArgs<ExtArgs>
    stops?: boolean | Location$stopsArgs<ExtArgs>
    _count?: boolean | LocationCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $LocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Location"
    objects: {
      routesFrom: Prisma.$RoutePayload<ExtArgs>[]
      routesTo: Prisma.$RoutePayload<ExtArgs>[]
      stops: Prisma.$StopPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      district: string
      state: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["location"]>
    composites: {}
  }

  type LocationGetPayload<S extends boolean | null | undefined | LocationDefaultArgs> = $Result.GetResult<Prisma.$LocationPayload, S>

  type LocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationCountAggregateInputType | true
    }

  export interface LocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Location'], meta: { name: 'Location' } }
    /**
     * Find zero or one Location that matches the filter.
     * @param {LocationFindUniqueArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationFindUniqueArgs>(args: SelectSubset<T, LocationFindUniqueArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Location that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationFindUniqueOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationFindFirstArgs>(args?: SelectSubset<T, LocationFindFirstArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Location that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindFirstOrThrowArgs} args - Arguments to find a Location
     * @example
     * // Get one Location
     * const location = await prisma.location.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Locations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Locations
     * const locations = await prisma.location.findMany()
     * 
     * // Get first 10 Locations
     * const locations = await prisma.location.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationWithIdOnly = await prisma.location.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationFindManyArgs>(args?: SelectSubset<T, LocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Location.
     * @param {LocationCreateArgs} args - Arguments to create a Location.
     * @example
     * // Create one Location
     * const Location = await prisma.location.create({
     *   data: {
     *     // ... data to create a Location
     *   }
     * })
     * 
     */
    create<T extends LocationCreateArgs>(args: SelectSubset<T, LocationCreateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Locations.
     * @param {LocationCreateManyArgs} args - Arguments to create many Locations.
     * @example
     * // Create many Locations
     * const location = await prisma.location.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationCreateManyArgs>(args?: SelectSubset<T, LocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Location.
     * @param {LocationDeleteArgs} args - Arguments to delete one Location.
     * @example
     * // Delete one Location
     * const Location = await prisma.location.delete({
     *   where: {
     *     // ... filter to delete one Location
     *   }
     * })
     * 
     */
    delete<T extends LocationDeleteArgs>(args: SelectSubset<T, LocationDeleteArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Location.
     * @param {LocationUpdateArgs} args - Arguments to update one Location.
     * @example
     * // Update one Location
     * const location = await prisma.location.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateArgs>(args: SelectSubset<T, LocationUpdateArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Locations.
     * @param {LocationDeleteManyArgs} args - Arguments to filter Locations to delete.
     * @example
     * // Delete a few Locations
     * const { count } = await prisma.location.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationDeleteManyArgs>(args?: SelectSubset<T, LocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Locations
     * const location = await prisma.location.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateManyArgs>(args: SelectSubset<T, LocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Location.
     * @param {LocationUpsertArgs} args - Arguments to update or create a Location.
     * @example
     * // Update or create a Location
     * const location = await prisma.location.upsert({
     *   create: {
     *     // ... data to create a Location
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Location we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpsertArgs>(args: SelectSubset<T, LocationUpsertArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Locations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationCountArgs} args - Arguments to filter Locations to count.
     * @example
     * // Count the number of Locations
     * const count = await prisma.location.count({
     *   where: {
     *     // ... the filter for the Locations we want to count
     *   }
     * })
    **/
    count<T extends LocationCountArgs>(
      args?: Subset<T, LocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationAggregateArgs>(args: Subset<T, LocationAggregateArgs>): Prisma.PrismaPromise<GetLocationAggregateType<T>>

    /**
     * Group by Location.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationGroupByArgs['orderBy'] }
        : { orderBy?: LocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Location model
   */
  readonly fields: LocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Location.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    routesFrom<T extends Location$routesFromArgs<ExtArgs> = {}>(args?: Subset<T, Location$routesFromArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    routesTo<T extends Location$routesToArgs<ExtArgs> = {}>(args?: Subset<T, Location$routesToArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stops<T extends Location$stopsArgs<ExtArgs> = {}>(args?: Subset<T, Location$stopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Location model
   */
  interface LocationFieldRefs {
    readonly id: FieldRef<"Location", 'String'>
    readonly name: FieldRef<"Location", 'String'>
    readonly district: FieldRef<"Location", 'String'>
    readonly state: FieldRef<"Location", 'String'>
    readonly isActive: FieldRef<"Location", 'Boolean'>
    readonly createdAt: FieldRef<"Location", 'DateTime'>
    readonly updatedAt: FieldRef<"Location", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Location findUnique
   */
  export type LocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findUniqueOrThrow
   */
  export type LocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location findFirst
   */
  export type LocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findFirstOrThrow
   */
  export type LocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Location to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Locations.
     */
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location findMany
   */
  export type LocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter, which Locations to fetch.
     */
    where?: LocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Locations to fetch.
     */
    orderBy?: LocationOrderByWithRelationInput | LocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Locations.
     */
    cursor?: LocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Locations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Locations.
     */
    skip?: number
    distinct?: LocationScalarFieldEnum | LocationScalarFieldEnum[]
  }

  /**
   * Location create
   */
  export type LocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to create a Location.
     */
    data: XOR<LocationCreateInput, LocationUncheckedCreateInput>
  }

  /**
   * Location createMany
   */
  export type LocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Locations.
     */
    data: LocationCreateManyInput | LocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Location update
   */
  export type LocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The data needed to update a Location.
     */
    data: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
    /**
     * Choose, which Location to update.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location updateMany
   */
  export type LocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Locations.
     */
    data: XOR<LocationUpdateManyMutationInput, LocationUncheckedUpdateManyInput>
    /**
     * Filter which Locations to update
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to update.
     */
    limit?: number
  }

  /**
   * Location upsert
   */
  export type LocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * The filter to search for the Location to update in case it exists.
     */
    where: LocationWhereUniqueInput
    /**
     * In case the Location found by the `where` argument doesn't exist, create a new Location with this data.
     */
    create: XOR<LocationCreateInput, LocationUncheckedCreateInput>
    /**
     * In case the Location was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateInput, LocationUncheckedUpdateInput>
  }

  /**
   * Location delete
   */
  export type LocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
    /**
     * Filter which Location to delete.
     */
    where: LocationWhereUniqueInput
  }

  /**
   * Location deleteMany
   */
  export type LocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Locations to delete
     */
    where?: LocationWhereInput
    /**
     * Limit how many Locations to delete.
     */
    limit?: number
  }

  /**
   * Location.routesFrom
   */
  export type Location$routesFromArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    where?: RouteWhereInput
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    cursor?: RouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Location.routesTo
   */
  export type Location$routesToArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    where?: RouteWhereInput
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    cursor?: RouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Location.stops
   */
  export type Location$stopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    where?: StopWhereInput
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    cursor?: StopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Location without action
   */
  export type LocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Location
     */
    select?: LocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Location
     */
    omit?: LocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationInclude<ExtArgs> | null
  }


  /**
   * Model Route
   */

  export type AggregateRoute = {
    _count: RouteCountAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  export type RouteMinAggregateOutputType = {
    id: string | null
    originId: string | null
    destinationId: string | null
    directionType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteMaxAggregateOutputType = {
    id: string | null
    originId: string | null
    destinationId: string | null
    directionType: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteCountAggregateOutputType = {
    id: number
    originId: number
    destinationId: number
    directionType: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RouteMinAggregateInputType = {
    id?: true
    originId?: true
    destinationId?: true
    directionType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteMaxAggregateInputType = {
    id?: true
    originId?: true
    destinationId?: true
    directionType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteCountAggregateInputType = {
    id?: true
    originId?: true
    destinationId?: true
    directionType?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Route to aggregate.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Routes
    **/
    _count?: true | RouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteMaxAggregateInputType
  }

  export type GetRouteAggregateType<T extends RouteAggregateArgs> = {
        [P in keyof T & keyof AggregateRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoute[P]>
      : GetScalarType<T[P], AggregateRoute[P]>
  }




  export type RouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteWhereInput
    orderBy?: RouteOrderByWithAggregationInput | RouteOrderByWithAggregationInput[]
    by: RouteScalarFieldEnum[] | RouteScalarFieldEnum
    having?: RouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteCountAggregateInputType | true
    _min?: RouteMinAggregateInputType
    _max?: RouteMaxAggregateInputType
  }

  export type RouteGroupByOutputType = {
    id: string
    originId: string
    destinationId: string
    directionType: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RouteCountAggregateOutputType | null
    _min: RouteMinAggregateOutputType | null
    _max: RouteMaxAggregateOutputType | null
  }

  type GetRouteGroupByPayload<T extends RouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteGroupByOutputType[P]>
            : GetScalarType<T[P], RouteGroupByOutputType[P]>
        }
      >
    >


  export type RouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originId?: boolean
    destinationId?: boolean
    directionType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    origin?: boolean | LocationDefaultArgs<ExtArgs>
    destination?: boolean | LocationDefaultArgs<ExtArgs>
    stops?: boolean | Route$stopsArgs<ExtArgs>
    fares?: boolean | Route$faresArgs<ExtArgs>
    availability?: boolean | Route$availabilityArgs<ExtArgs>
    _count?: boolean | RouteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["route"]>



  export type RouteSelectScalar = {
    id?: boolean
    originId?: boolean
    destinationId?: boolean
    directionType?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RouteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "originId" | "destinationId" | "directionType" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["route"]>
  export type RouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | LocationDefaultArgs<ExtArgs>
    destination?: boolean | LocationDefaultArgs<ExtArgs>
    stops?: boolean | Route$stopsArgs<ExtArgs>
    fares?: boolean | Route$faresArgs<ExtArgs>
    availability?: boolean | Route$availabilityArgs<ExtArgs>
    _count?: boolean | RouteCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Route"
    objects: {
      origin: Prisma.$LocationPayload<ExtArgs>
      destination: Prisma.$LocationPayload<ExtArgs>
      stops: Prisma.$StopPayload<ExtArgs>[]
      fares: Prisma.$RouteFarePayload<ExtArgs>[]
      availability: Prisma.$RouteAvailabilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      originId: string
      destinationId: string
      directionType: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["route"]>
    composites: {}
  }

  type RouteGetPayload<S extends boolean | null | undefined | RouteDefaultArgs> = $Result.GetResult<Prisma.$RoutePayload, S>

  type RouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RouteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RouteCountAggregateInputType | true
    }

  export interface RouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Route'], meta: { name: 'Route' } }
    /**
     * Find zero or one Route that matches the filter.
     * @param {RouteFindUniqueArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteFindUniqueArgs>(args: SelectSubset<T, RouteFindUniqueArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Route that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RouteFindUniqueOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Route that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteFindFirstArgs>(args?: SelectSubset<T, RouteFindFirstArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Route that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindFirstOrThrowArgs} args - Arguments to find a Route
     * @example
     * // Get one Route
     * const route = await prisma.route.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Routes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Routes
     * const routes = await prisma.route.findMany()
     * 
     * // Get first 10 Routes
     * const routes = await prisma.route.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeWithIdOnly = await prisma.route.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteFindManyArgs>(args?: SelectSubset<T, RouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Route.
     * @param {RouteCreateArgs} args - Arguments to create a Route.
     * @example
     * // Create one Route
     * const Route = await prisma.route.create({
     *   data: {
     *     // ... data to create a Route
     *   }
     * })
     * 
     */
    create<T extends RouteCreateArgs>(args: SelectSubset<T, RouteCreateArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Routes.
     * @param {RouteCreateManyArgs} args - Arguments to create many Routes.
     * @example
     * // Create many Routes
     * const route = await prisma.route.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteCreateManyArgs>(args?: SelectSubset<T, RouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Route.
     * @param {RouteDeleteArgs} args - Arguments to delete one Route.
     * @example
     * // Delete one Route
     * const Route = await prisma.route.delete({
     *   where: {
     *     // ... filter to delete one Route
     *   }
     * })
     * 
     */
    delete<T extends RouteDeleteArgs>(args: SelectSubset<T, RouteDeleteArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Route.
     * @param {RouteUpdateArgs} args - Arguments to update one Route.
     * @example
     * // Update one Route
     * const route = await prisma.route.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteUpdateArgs>(args: SelectSubset<T, RouteUpdateArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Routes.
     * @param {RouteDeleteManyArgs} args - Arguments to filter Routes to delete.
     * @example
     * // Delete a few Routes
     * const { count } = await prisma.route.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteDeleteManyArgs>(args?: SelectSubset<T, RouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Routes
     * const route = await prisma.route.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteUpdateManyArgs>(args: SelectSubset<T, RouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Route.
     * @param {RouteUpsertArgs} args - Arguments to update or create a Route.
     * @example
     * // Update or create a Route
     * const route = await prisma.route.upsert({
     *   create: {
     *     // ... data to create a Route
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Route we want to update
     *   }
     * })
     */
    upsert<T extends RouteUpsertArgs>(args: SelectSubset<T, RouteUpsertArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Routes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteCountArgs} args - Arguments to filter Routes to count.
     * @example
     * // Count the number of Routes
     * const count = await prisma.route.count({
     *   where: {
     *     // ... the filter for the Routes we want to count
     *   }
     * })
    **/
    count<T extends RouteCountArgs>(
      args?: Subset<T, RouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteAggregateArgs>(args: Subset<T, RouteAggregateArgs>): Prisma.PrismaPromise<GetRouteAggregateType<T>>

    /**
     * Group by Route.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteGroupByArgs['orderBy'] }
        : { orderBy?: RouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Route model
   */
  readonly fields: RouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Route.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    origin<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    destination<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stops<T extends Route$stopsArgs<ExtArgs> = {}>(args?: Subset<T, Route$stopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fares<T extends Route$faresArgs<ExtArgs> = {}>(args?: Subset<T, Route$faresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteFarePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    availability<T extends Route$availabilityArgs<ExtArgs> = {}>(args?: Subset<T, Route$availabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteAvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Route model
   */
  interface RouteFieldRefs {
    readonly id: FieldRef<"Route", 'String'>
    readonly originId: FieldRef<"Route", 'String'>
    readonly destinationId: FieldRef<"Route", 'String'>
    readonly directionType: FieldRef<"Route", 'String'>
    readonly isActive: FieldRef<"Route", 'Boolean'>
    readonly createdAt: FieldRef<"Route", 'DateTime'>
    readonly updatedAt: FieldRef<"Route", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Route findUnique
   */
  export type RouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route findUniqueOrThrow
   */
  export type RouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route findFirst
   */
  export type RouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route findFirstOrThrow
   */
  export type RouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Route to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Routes.
     */
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route findMany
   */
  export type RouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter, which Routes to fetch.
     */
    where?: RouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Routes to fetch.
     */
    orderBy?: RouteOrderByWithRelationInput | RouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Routes.
     */
    cursor?: RouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Routes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Routes.
     */
    skip?: number
    distinct?: RouteScalarFieldEnum | RouteScalarFieldEnum[]
  }

  /**
   * Route create
   */
  export type RouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The data needed to create a Route.
     */
    data: XOR<RouteCreateInput, RouteUncheckedCreateInput>
  }

  /**
   * Route createMany
   */
  export type RouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Routes.
     */
    data: RouteCreateManyInput | RouteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Route update
   */
  export type RouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The data needed to update a Route.
     */
    data: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
    /**
     * Choose, which Route to update.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route updateMany
   */
  export type RouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Routes.
     */
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyInput>
    /**
     * Filter which Routes to update
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to update.
     */
    limit?: number
  }

  /**
   * Route upsert
   */
  export type RouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * The filter to search for the Route to update in case it exists.
     */
    where: RouteWhereUniqueInput
    /**
     * In case the Route found by the `where` argument doesn't exist, create a new Route with this data.
     */
    create: XOR<RouteCreateInput, RouteUncheckedCreateInput>
    /**
     * In case the Route was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteUpdateInput, RouteUncheckedUpdateInput>
  }

  /**
   * Route delete
   */
  export type RouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
    /**
     * Filter which Route to delete.
     */
    where: RouteWhereUniqueInput
  }

  /**
   * Route deleteMany
   */
  export type RouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Routes to delete
     */
    where?: RouteWhereInput
    /**
     * Limit how many Routes to delete.
     */
    limit?: number
  }

  /**
   * Route.stops
   */
  export type Route$stopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    where?: StopWhereInput
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    cursor?: StopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Route.fares
   */
  export type Route$faresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFare
     */
    select?: RouteFareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFare
     */
    omit?: RouteFareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFareInclude<ExtArgs> | null
    where?: RouteFareWhereInput
    orderBy?: RouteFareOrderByWithRelationInput | RouteFareOrderByWithRelationInput[]
    cursor?: RouteFareWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteFareScalarFieldEnum | RouteFareScalarFieldEnum[]
  }

  /**
   * Route.availability
   */
  export type Route$availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteAvailability
     */
    select?: RouteAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteAvailability
     */
    omit?: RouteAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteAvailabilityInclude<ExtArgs> | null
    where?: RouteAvailabilityWhereInput
    orderBy?: RouteAvailabilityOrderByWithRelationInput | RouteAvailabilityOrderByWithRelationInput[]
    cursor?: RouteAvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteAvailabilityScalarFieldEnum | RouteAvailabilityScalarFieldEnum[]
  }

  /**
   * Route without action
   */
  export type RouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Route
     */
    select?: RouteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Route
     */
    omit?: RouteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteInclude<ExtArgs> | null
  }


  /**
   * Model Stop
   */

  export type AggregateStop = {
    _count: StopCountAggregateOutputType | null
    _avg: StopAvgAggregateOutputType | null
    _sum: StopSumAggregateOutputType | null
    _min: StopMinAggregateOutputType | null
    _max: StopMaxAggregateOutputType | null
  }

  export type StopAvgAggregateOutputType = {
    order: number | null
    distanceKm: number | null
  }

  export type StopSumAggregateOutputType = {
    order: number | null
    distanceKm: number | null
  }

  export type StopMinAggregateOutputType = {
    id: string | null
    routeId: string | null
    locationId: string | null
    name: string | null
    order: number | null
    distanceKm: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StopMaxAggregateOutputType = {
    id: string | null
    routeId: string | null
    locationId: string | null
    name: string | null
    order: number | null
    distanceKm: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StopCountAggregateOutputType = {
    id: number
    routeId: number
    locationId: number
    name: number
    order: number
    distanceKm: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StopAvgAggregateInputType = {
    order?: true
    distanceKm?: true
  }

  export type StopSumAggregateInputType = {
    order?: true
    distanceKm?: true
  }

  export type StopMinAggregateInputType = {
    id?: true
    routeId?: true
    locationId?: true
    name?: true
    order?: true
    distanceKm?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StopMaxAggregateInputType = {
    id?: true
    routeId?: true
    locationId?: true
    name?: true
    order?: true
    distanceKm?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StopCountAggregateInputType = {
    id?: true
    routeId?: true
    locationId?: true
    name?: true
    order?: true
    distanceKm?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stop to aggregate.
     */
    where?: StopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stops to fetch.
     */
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stops
    **/
    _count?: true | StopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StopMaxAggregateInputType
  }

  export type GetStopAggregateType<T extends StopAggregateArgs> = {
        [P in keyof T & keyof AggregateStop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStop[P]>
      : GetScalarType<T[P], AggregateStop[P]>
  }




  export type StopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StopWhereInput
    orderBy?: StopOrderByWithAggregationInput | StopOrderByWithAggregationInput[]
    by: StopScalarFieldEnum[] | StopScalarFieldEnum
    having?: StopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StopCountAggregateInputType | true
    _avg?: StopAvgAggregateInputType
    _sum?: StopSumAggregateInputType
    _min?: StopMinAggregateInputType
    _max?: StopMaxAggregateInputType
  }

  export type StopGroupByOutputType = {
    id: string
    routeId: string
    locationId: string
    name: string
    order: number
    distanceKm: number | null
    createdAt: Date
    updatedAt: Date
    _count: StopCountAggregateOutputType | null
    _avg: StopAvgAggregateOutputType | null
    _sum: StopSumAggregateOutputType | null
    _min: StopMinAggregateOutputType | null
    _max: StopMaxAggregateOutputType | null
  }

  type GetStopGroupByPayload<T extends StopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StopGroupByOutputType[P]>
            : GetScalarType<T[P], StopGroupByOutputType[P]>
        }
      >
    >


  export type StopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    locationId?: boolean
    name?: boolean
    order?: boolean
    distanceKm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    route?: boolean | RouteDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stop"]>



  export type StopSelectScalar = {
    id?: boolean
    routeId?: boolean
    locationId?: boolean
    name?: boolean
    order?: boolean
    distanceKm?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "routeId" | "locationId" | "name" | "order" | "distanceKm" | "createdAt" | "updatedAt", ExtArgs["result"]["stop"]>
  export type StopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteDefaultArgs<ExtArgs>
    location?: boolean | LocationDefaultArgs<ExtArgs>
  }

  export type $StopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stop"
    objects: {
      route: Prisma.$RoutePayload<ExtArgs>
      location: Prisma.$LocationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      routeId: string
      locationId: string
      name: string
      order: number
      distanceKm: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stop"]>
    composites: {}
  }

  type StopGetPayload<S extends boolean | null | undefined | StopDefaultArgs> = $Result.GetResult<Prisma.$StopPayload, S>

  type StopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StopCountAggregateInputType | true
    }

  export interface StopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stop'], meta: { name: 'Stop' } }
    /**
     * Find zero or one Stop that matches the filter.
     * @param {StopFindUniqueArgs} args - Arguments to find a Stop
     * @example
     * // Get one Stop
     * const stop = await prisma.stop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StopFindUniqueArgs>(args: SelectSubset<T, StopFindUniqueArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StopFindUniqueOrThrowArgs} args - Arguments to find a Stop
     * @example
     * // Get one Stop
     * const stop = await prisma.stop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StopFindUniqueOrThrowArgs>(args: SelectSubset<T, StopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopFindFirstArgs} args - Arguments to find a Stop
     * @example
     * // Get one Stop
     * const stop = await prisma.stop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StopFindFirstArgs>(args?: SelectSubset<T, StopFindFirstArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopFindFirstOrThrowArgs} args - Arguments to find a Stop
     * @example
     * // Get one Stop
     * const stop = await prisma.stop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StopFindFirstOrThrowArgs>(args?: SelectSubset<T, StopFindFirstOrThrowArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stops
     * const stops = await prisma.stop.findMany()
     * 
     * // Get first 10 Stops
     * const stops = await prisma.stop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stopWithIdOnly = await prisma.stop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StopFindManyArgs>(args?: SelectSubset<T, StopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stop.
     * @param {StopCreateArgs} args - Arguments to create a Stop.
     * @example
     * // Create one Stop
     * const Stop = await prisma.stop.create({
     *   data: {
     *     // ... data to create a Stop
     *   }
     * })
     * 
     */
    create<T extends StopCreateArgs>(args: SelectSubset<T, StopCreateArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stops.
     * @param {StopCreateManyArgs} args - Arguments to create many Stops.
     * @example
     * // Create many Stops
     * const stop = await prisma.stop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StopCreateManyArgs>(args?: SelectSubset<T, StopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stop.
     * @param {StopDeleteArgs} args - Arguments to delete one Stop.
     * @example
     * // Delete one Stop
     * const Stop = await prisma.stop.delete({
     *   where: {
     *     // ... filter to delete one Stop
     *   }
     * })
     * 
     */
    delete<T extends StopDeleteArgs>(args: SelectSubset<T, StopDeleteArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stop.
     * @param {StopUpdateArgs} args - Arguments to update one Stop.
     * @example
     * // Update one Stop
     * const stop = await prisma.stop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StopUpdateArgs>(args: SelectSubset<T, StopUpdateArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stops.
     * @param {StopDeleteManyArgs} args - Arguments to filter Stops to delete.
     * @example
     * // Delete a few Stops
     * const { count } = await prisma.stop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StopDeleteManyArgs>(args?: SelectSubset<T, StopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stops
     * const stop = await prisma.stop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StopUpdateManyArgs>(args: SelectSubset<T, StopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stop.
     * @param {StopUpsertArgs} args - Arguments to update or create a Stop.
     * @example
     * // Update or create a Stop
     * const stop = await prisma.stop.upsert({
     *   create: {
     *     // ... data to create a Stop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stop we want to update
     *   }
     * })
     */
    upsert<T extends StopUpsertArgs>(args: SelectSubset<T, StopUpsertArgs<ExtArgs>>): Prisma__StopClient<$Result.GetResult<Prisma.$StopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopCountArgs} args - Arguments to filter Stops to count.
     * @example
     * // Count the number of Stops
     * const count = await prisma.stop.count({
     *   where: {
     *     // ... the filter for the Stops we want to count
     *   }
     * })
    **/
    count<T extends StopCountArgs>(
      args?: Subset<T, StopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StopAggregateArgs>(args: Subset<T, StopAggregateArgs>): Prisma.PrismaPromise<GetStopAggregateType<T>>

    /**
     * Group by Stop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StopGroupByArgs['orderBy'] }
        : { orderBy?: StopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stop model
   */
  readonly fields: StopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    route<T extends RouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteDefaultArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    location<T extends LocationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LocationDefaultArgs<ExtArgs>>): Prisma__LocationClient<$Result.GetResult<Prisma.$LocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stop model
   */
  interface StopFieldRefs {
    readonly id: FieldRef<"Stop", 'String'>
    readonly routeId: FieldRef<"Stop", 'String'>
    readonly locationId: FieldRef<"Stop", 'String'>
    readonly name: FieldRef<"Stop", 'String'>
    readonly order: FieldRef<"Stop", 'Int'>
    readonly distanceKm: FieldRef<"Stop", 'Float'>
    readonly createdAt: FieldRef<"Stop", 'DateTime'>
    readonly updatedAt: FieldRef<"Stop", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stop findUnique
   */
  export type StopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stop to fetch.
     */
    where: StopWhereUniqueInput
  }

  /**
   * Stop findUniqueOrThrow
   */
  export type StopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stop to fetch.
     */
    where: StopWhereUniqueInput
  }

  /**
   * Stop findFirst
   */
  export type StopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stop to fetch.
     */
    where?: StopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stops to fetch.
     */
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stops.
     */
    cursor?: StopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stops.
     */
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Stop findFirstOrThrow
   */
  export type StopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stop to fetch.
     */
    where?: StopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stops to fetch.
     */
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stops.
     */
    cursor?: StopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stops.
     */
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Stop findMany
   */
  export type StopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter, which Stops to fetch.
     */
    where?: StopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stops to fetch.
     */
    orderBy?: StopOrderByWithRelationInput | StopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stops.
     */
    cursor?: StopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stops.
     */
    skip?: number
    distinct?: StopScalarFieldEnum | StopScalarFieldEnum[]
  }

  /**
   * Stop create
   */
  export type StopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * The data needed to create a Stop.
     */
    data: XOR<StopCreateInput, StopUncheckedCreateInput>
  }

  /**
   * Stop createMany
   */
  export type StopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stops.
     */
    data: StopCreateManyInput | StopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stop update
   */
  export type StopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * The data needed to update a Stop.
     */
    data: XOR<StopUpdateInput, StopUncheckedUpdateInput>
    /**
     * Choose, which Stop to update.
     */
    where: StopWhereUniqueInput
  }

  /**
   * Stop updateMany
   */
  export type StopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stops.
     */
    data: XOR<StopUpdateManyMutationInput, StopUncheckedUpdateManyInput>
    /**
     * Filter which Stops to update
     */
    where?: StopWhereInput
    /**
     * Limit how many Stops to update.
     */
    limit?: number
  }

  /**
   * Stop upsert
   */
  export type StopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * The filter to search for the Stop to update in case it exists.
     */
    where: StopWhereUniqueInput
    /**
     * In case the Stop found by the `where` argument doesn't exist, create a new Stop with this data.
     */
    create: XOR<StopCreateInput, StopUncheckedCreateInput>
    /**
     * In case the Stop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StopUpdateInput, StopUncheckedUpdateInput>
  }

  /**
   * Stop delete
   */
  export type StopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
    /**
     * Filter which Stop to delete.
     */
    where: StopWhereUniqueInput
  }

  /**
   * Stop deleteMany
   */
  export type StopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stops to delete
     */
    where?: StopWhereInput
    /**
     * Limit how many Stops to delete.
     */
    limit?: number
  }

  /**
   * Stop without action
   */
  export type StopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stop
     */
    select?: StopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stop
     */
    omit?: StopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StopInclude<ExtArgs> | null
  }


  /**
   * Model RouteFare
   */

  export type AggregateRouteFare = {
    _count: RouteFareCountAggregateOutputType | null
    _avg: RouteFareAvgAggregateOutputType | null
    _sum: RouteFareSumAggregateOutputType | null
    _min: RouteFareMinAggregateOutputType | null
    _max: RouteFareMaxAggregateOutputType | null
  }

  export type RouteFareAvgAggregateOutputType = {
    baseFare: number | null
    perKmRate: number | null
    perHourRate: number | null
    nightCharge: number | null
    hillCharge: number | null
    waitingCharge: number | null
  }

  export type RouteFareSumAggregateOutputType = {
    baseFare: number | null
    perKmRate: number | null
    perHourRate: number | null
    nightCharge: number | null
    hillCharge: number | null
    waitingCharge: number | null
  }

  export type RouteFareMinAggregateOutputType = {
    id: string | null
    routeId: string | null
    vehicleType: string | null
    pricingType: string | null
    baseFare: number | null
    perKmRate: number | null
    perHourRate: number | null
    nightCharge: number | null
    hillCharge: number | null
    waitingCharge: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteFareMaxAggregateOutputType = {
    id: string | null
    routeId: string | null
    vehicleType: string | null
    pricingType: string | null
    baseFare: number | null
    perKmRate: number | null
    perHourRate: number | null
    nightCharge: number | null
    hillCharge: number | null
    waitingCharge: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteFareCountAggregateOutputType = {
    id: number
    routeId: number
    vehicleType: number
    pricingType: number
    baseFare: number
    perKmRate: number
    perHourRate: number
    nightCharge: number
    hillCharge: number
    waitingCharge: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RouteFareAvgAggregateInputType = {
    baseFare?: true
    perKmRate?: true
    perHourRate?: true
    nightCharge?: true
    hillCharge?: true
    waitingCharge?: true
  }

  export type RouteFareSumAggregateInputType = {
    baseFare?: true
    perKmRate?: true
    perHourRate?: true
    nightCharge?: true
    hillCharge?: true
    waitingCharge?: true
  }

  export type RouteFareMinAggregateInputType = {
    id?: true
    routeId?: true
    vehicleType?: true
    pricingType?: true
    baseFare?: true
    perKmRate?: true
    perHourRate?: true
    nightCharge?: true
    hillCharge?: true
    waitingCharge?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteFareMaxAggregateInputType = {
    id?: true
    routeId?: true
    vehicleType?: true
    pricingType?: true
    baseFare?: true
    perKmRate?: true
    perHourRate?: true
    nightCharge?: true
    hillCharge?: true
    waitingCharge?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteFareCountAggregateInputType = {
    id?: true
    routeId?: true
    vehicleType?: true
    pricingType?: true
    baseFare?: true
    perKmRate?: true
    perHourRate?: true
    nightCharge?: true
    hillCharge?: true
    waitingCharge?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RouteFareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteFare to aggregate.
     */
    where?: RouteFareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteFares to fetch.
     */
    orderBy?: RouteFareOrderByWithRelationInput | RouteFareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteFareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteFares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteFares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RouteFares
    **/
    _count?: true | RouteFareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteFareAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteFareSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteFareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteFareMaxAggregateInputType
  }

  export type GetRouteFareAggregateType<T extends RouteFareAggregateArgs> = {
        [P in keyof T & keyof AggregateRouteFare]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRouteFare[P]>
      : GetScalarType<T[P], AggregateRouteFare[P]>
  }




  export type RouteFareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteFareWhereInput
    orderBy?: RouteFareOrderByWithAggregationInput | RouteFareOrderByWithAggregationInput[]
    by: RouteFareScalarFieldEnum[] | RouteFareScalarFieldEnum
    having?: RouteFareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteFareCountAggregateInputType | true
    _avg?: RouteFareAvgAggregateInputType
    _sum?: RouteFareSumAggregateInputType
    _min?: RouteFareMinAggregateInputType
    _max?: RouteFareMaxAggregateInputType
  }

  export type RouteFareGroupByOutputType = {
    id: string
    routeId: string
    vehicleType: string
    pricingType: string
    baseFare: number
    perKmRate: number | null
    perHourRate: number | null
    nightCharge: number | null
    hillCharge: number | null
    waitingCharge: number | null
    createdAt: Date
    updatedAt: Date
    _count: RouteFareCountAggregateOutputType | null
    _avg: RouteFareAvgAggregateOutputType | null
    _sum: RouteFareSumAggregateOutputType | null
    _min: RouteFareMinAggregateOutputType | null
    _max: RouteFareMaxAggregateOutputType | null
  }

  type GetRouteFareGroupByPayload<T extends RouteFareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteFareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteFareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteFareGroupByOutputType[P]>
            : GetScalarType<T[P], RouteFareGroupByOutputType[P]>
        }
      >
    >


  export type RouteFareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    vehicleType?: boolean
    pricingType?: boolean
    baseFare?: boolean
    perKmRate?: boolean
    perHourRate?: boolean
    nightCharge?: boolean
    hillCharge?: boolean
    waitingCharge?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeFare"]>



  export type RouteFareSelectScalar = {
    id?: boolean
    routeId?: boolean
    vehicleType?: boolean
    pricingType?: boolean
    baseFare?: boolean
    perKmRate?: boolean
    perHourRate?: boolean
    nightCharge?: boolean
    hillCharge?: boolean
    waitingCharge?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RouteFareOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "routeId" | "vehicleType" | "pricingType" | "baseFare" | "perKmRate" | "perHourRate" | "nightCharge" | "hillCharge" | "waitingCharge" | "createdAt" | "updatedAt", ExtArgs["result"]["routeFare"]>
  export type RouteFareInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }

  export type $RouteFarePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RouteFare"
    objects: {
      route: Prisma.$RoutePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      routeId: string
      vehicleType: string
      pricingType: string
      baseFare: number
      perKmRate: number | null
      perHourRate: number | null
      nightCharge: number | null
      hillCharge: number | null
      waitingCharge: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["routeFare"]>
    composites: {}
  }

  type RouteFareGetPayload<S extends boolean | null | undefined | RouteFareDefaultArgs> = $Result.GetResult<Prisma.$RouteFarePayload, S>

  type RouteFareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RouteFareFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RouteFareCountAggregateInputType | true
    }

  export interface RouteFareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RouteFare'], meta: { name: 'RouteFare' } }
    /**
     * Find zero or one RouteFare that matches the filter.
     * @param {RouteFareFindUniqueArgs} args - Arguments to find a RouteFare
     * @example
     * // Get one RouteFare
     * const routeFare = await prisma.routeFare.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteFareFindUniqueArgs>(args: SelectSubset<T, RouteFareFindUniqueArgs<ExtArgs>>): Prisma__RouteFareClient<$Result.GetResult<Prisma.$RouteFarePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RouteFare that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RouteFareFindUniqueOrThrowArgs} args - Arguments to find a RouteFare
     * @example
     * // Get one RouteFare
     * const routeFare = await prisma.routeFare.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteFareFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteFareFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteFareClient<$Result.GetResult<Prisma.$RouteFarePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteFare that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFareFindFirstArgs} args - Arguments to find a RouteFare
     * @example
     * // Get one RouteFare
     * const routeFare = await prisma.routeFare.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteFareFindFirstArgs>(args?: SelectSubset<T, RouteFareFindFirstArgs<ExtArgs>>): Prisma__RouteFareClient<$Result.GetResult<Prisma.$RouteFarePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteFare that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFareFindFirstOrThrowArgs} args - Arguments to find a RouteFare
     * @example
     * // Get one RouteFare
     * const routeFare = await prisma.routeFare.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteFareFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteFareFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteFareClient<$Result.GetResult<Prisma.$RouteFarePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RouteFares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFareFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RouteFares
     * const routeFares = await prisma.routeFare.findMany()
     * 
     * // Get first 10 RouteFares
     * const routeFares = await prisma.routeFare.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeFareWithIdOnly = await prisma.routeFare.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteFareFindManyArgs>(args?: SelectSubset<T, RouteFareFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteFarePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RouteFare.
     * @param {RouteFareCreateArgs} args - Arguments to create a RouteFare.
     * @example
     * // Create one RouteFare
     * const RouteFare = await prisma.routeFare.create({
     *   data: {
     *     // ... data to create a RouteFare
     *   }
     * })
     * 
     */
    create<T extends RouteFareCreateArgs>(args: SelectSubset<T, RouteFareCreateArgs<ExtArgs>>): Prisma__RouteFareClient<$Result.GetResult<Prisma.$RouteFarePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RouteFares.
     * @param {RouteFareCreateManyArgs} args - Arguments to create many RouteFares.
     * @example
     * // Create many RouteFares
     * const routeFare = await prisma.routeFare.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteFareCreateManyArgs>(args?: SelectSubset<T, RouteFareCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RouteFare.
     * @param {RouteFareDeleteArgs} args - Arguments to delete one RouteFare.
     * @example
     * // Delete one RouteFare
     * const RouteFare = await prisma.routeFare.delete({
     *   where: {
     *     // ... filter to delete one RouteFare
     *   }
     * })
     * 
     */
    delete<T extends RouteFareDeleteArgs>(args: SelectSubset<T, RouteFareDeleteArgs<ExtArgs>>): Prisma__RouteFareClient<$Result.GetResult<Prisma.$RouteFarePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RouteFare.
     * @param {RouteFareUpdateArgs} args - Arguments to update one RouteFare.
     * @example
     * // Update one RouteFare
     * const routeFare = await prisma.routeFare.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteFareUpdateArgs>(args: SelectSubset<T, RouteFareUpdateArgs<ExtArgs>>): Prisma__RouteFareClient<$Result.GetResult<Prisma.$RouteFarePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RouteFares.
     * @param {RouteFareDeleteManyArgs} args - Arguments to filter RouteFares to delete.
     * @example
     * // Delete a few RouteFares
     * const { count } = await prisma.routeFare.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteFareDeleteManyArgs>(args?: SelectSubset<T, RouteFareDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteFares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RouteFares
     * const routeFare = await prisma.routeFare.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteFareUpdateManyArgs>(args: SelectSubset<T, RouteFareUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RouteFare.
     * @param {RouteFareUpsertArgs} args - Arguments to update or create a RouteFare.
     * @example
     * // Update or create a RouteFare
     * const routeFare = await prisma.routeFare.upsert({
     *   create: {
     *     // ... data to create a RouteFare
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RouteFare we want to update
     *   }
     * })
     */
    upsert<T extends RouteFareUpsertArgs>(args: SelectSubset<T, RouteFareUpsertArgs<ExtArgs>>): Prisma__RouteFareClient<$Result.GetResult<Prisma.$RouteFarePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RouteFares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFareCountArgs} args - Arguments to filter RouteFares to count.
     * @example
     * // Count the number of RouteFares
     * const count = await prisma.routeFare.count({
     *   where: {
     *     // ... the filter for the RouteFares we want to count
     *   }
     * })
    **/
    count<T extends RouteFareCountArgs>(
      args?: Subset<T, RouteFareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteFareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RouteFare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteFareAggregateArgs>(args: Subset<T, RouteFareAggregateArgs>): Prisma.PrismaPromise<GetRouteFareAggregateType<T>>

    /**
     * Group by RouteFare.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteFareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteFareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteFareGroupByArgs['orderBy'] }
        : { orderBy?: RouteFareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteFareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteFareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RouteFare model
   */
  readonly fields: RouteFareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RouteFare.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteFareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    route<T extends RouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteDefaultArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RouteFare model
   */
  interface RouteFareFieldRefs {
    readonly id: FieldRef<"RouteFare", 'String'>
    readonly routeId: FieldRef<"RouteFare", 'String'>
    readonly vehicleType: FieldRef<"RouteFare", 'String'>
    readonly pricingType: FieldRef<"RouteFare", 'String'>
    readonly baseFare: FieldRef<"RouteFare", 'Float'>
    readonly perKmRate: FieldRef<"RouteFare", 'Float'>
    readonly perHourRate: FieldRef<"RouteFare", 'Float'>
    readonly nightCharge: FieldRef<"RouteFare", 'Float'>
    readonly hillCharge: FieldRef<"RouteFare", 'Float'>
    readonly waitingCharge: FieldRef<"RouteFare", 'Float'>
    readonly createdAt: FieldRef<"RouteFare", 'DateTime'>
    readonly updatedAt: FieldRef<"RouteFare", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RouteFare findUnique
   */
  export type RouteFareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFare
     */
    select?: RouteFareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFare
     */
    omit?: RouteFareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFareInclude<ExtArgs> | null
    /**
     * Filter, which RouteFare to fetch.
     */
    where: RouteFareWhereUniqueInput
  }

  /**
   * RouteFare findUniqueOrThrow
   */
  export type RouteFareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFare
     */
    select?: RouteFareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFare
     */
    omit?: RouteFareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFareInclude<ExtArgs> | null
    /**
     * Filter, which RouteFare to fetch.
     */
    where: RouteFareWhereUniqueInput
  }

  /**
   * RouteFare findFirst
   */
  export type RouteFareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFare
     */
    select?: RouteFareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFare
     */
    omit?: RouteFareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFareInclude<ExtArgs> | null
    /**
     * Filter, which RouteFare to fetch.
     */
    where?: RouteFareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteFares to fetch.
     */
    orderBy?: RouteFareOrderByWithRelationInput | RouteFareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteFares.
     */
    cursor?: RouteFareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteFares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteFares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteFares.
     */
    distinct?: RouteFareScalarFieldEnum | RouteFareScalarFieldEnum[]
  }

  /**
   * RouteFare findFirstOrThrow
   */
  export type RouteFareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFare
     */
    select?: RouteFareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFare
     */
    omit?: RouteFareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFareInclude<ExtArgs> | null
    /**
     * Filter, which RouteFare to fetch.
     */
    where?: RouteFareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteFares to fetch.
     */
    orderBy?: RouteFareOrderByWithRelationInput | RouteFareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteFares.
     */
    cursor?: RouteFareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteFares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteFares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteFares.
     */
    distinct?: RouteFareScalarFieldEnum | RouteFareScalarFieldEnum[]
  }

  /**
   * RouteFare findMany
   */
  export type RouteFareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFare
     */
    select?: RouteFareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFare
     */
    omit?: RouteFareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFareInclude<ExtArgs> | null
    /**
     * Filter, which RouteFares to fetch.
     */
    where?: RouteFareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteFares to fetch.
     */
    orderBy?: RouteFareOrderByWithRelationInput | RouteFareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RouteFares.
     */
    cursor?: RouteFareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteFares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteFares.
     */
    skip?: number
    distinct?: RouteFareScalarFieldEnum | RouteFareScalarFieldEnum[]
  }

  /**
   * RouteFare create
   */
  export type RouteFareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFare
     */
    select?: RouteFareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFare
     */
    omit?: RouteFareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFareInclude<ExtArgs> | null
    /**
     * The data needed to create a RouteFare.
     */
    data: XOR<RouteFareCreateInput, RouteFareUncheckedCreateInput>
  }

  /**
   * RouteFare createMany
   */
  export type RouteFareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RouteFares.
     */
    data: RouteFareCreateManyInput | RouteFareCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteFare update
   */
  export type RouteFareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFare
     */
    select?: RouteFareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFare
     */
    omit?: RouteFareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFareInclude<ExtArgs> | null
    /**
     * The data needed to update a RouteFare.
     */
    data: XOR<RouteFareUpdateInput, RouteFareUncheckedUpdateInput>
    /**
     * Choose, which RouteFare to update.
     */
    where: RouteFareWhereUniqueInput
  }

  /**
   * RouteFare updateMany
   */
  export type RouteFareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RouteFares.
     */
    data: XOR<RouteFareUpdateManyMutationInput, RouteFareUncheckedUpdateManyInput>
    /**
     * Filter which RouteFares to update
     */
    where?: RouteFareWhereInput
    /**
     * Limit how many RouteFares to update.
     */
    limit?: number
  }

  /**
   * RouteFare upsert
   */
  export type RouteFareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFare
     */
    select?: RouteFareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFare
     */
    omit?: RouteFareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFareInclude<ExtArgs> | null
    /**
     * The filter to search for the RouteFare to update in case it exists.
     */
    where: RouteFareWhereUniqueInput
    /**
     * In case the RouteFare found by the `where` argument doesn't exist, create a new RouteFare with this data.
     */
    create: XOR<RouteFareCreateInput, RouteFareUncheckedCreateInput>
    /**
     * In case the RouteFare was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteFareUpdateInput, RouteFareUncheckedUpdateInput>
  }

  /**
   * RouteFare delete
   */
  export type RouteFareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFare
     */
    select?: RouteFareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFare
     */
    omit?: RouteFareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFareInclude<ExtArgs> | null
    /**
     * Filter which RouteFare to delete.
     */
    where: RouteFareWhereUniqueInput
  }

  /**
   * RouteFare deleteMany
   */
  export type RouteFareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteFares to delete
     */
    where?: RouteFareWhereInput
    /**
     * Limit how many RouteFares to delete.
     */
    limit?: number
  }

  /**
   * RouteFare without action
   */
  export type RouteFareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteFare
     */
    select?: RouteFareSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteFare
     */
    omit?: RouteFareOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteFareInclude<ExtArgs> | null
  }


  /**
   * Model RouteAvailability
   */

  export type AggregateRouteAvailability = {
    _count: RouteAvailabilityCountAggregateOutputType | null
    _min: RouteAvailabilityMinAggregateOutputType | null
    _max: RouteAvailabilityMaxAggregateOutputType | null
  }

  export type RouteAvailabilityMinAggregateOutputType = {
    id: string | null
    routeId: string | null
    vehicleType: string | null
    isAvailable: boolean | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteAvailabilityMaxAggregateOutputType = {
    id: string | null
    routeId: string | null
    vehicleType: string | null
    isAvailable: boolean | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RouteAvailabilityCountAggregateOutputType = {
    id: number
    routeId: number
    vehicleType: number
    isAvailable: number
    reason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RouteAvailabilityMinAggregateInputType = {
    id?: true
    routeId?: true
    vehicleType?: true
    isAvailable?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteAvailabilityMaxAggregateInputType = {
    id?: true
    routeId?: true
    vehicleType?: true
    isAvailable?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RouteAvailabilityCountAggregateInputType = {
    id?: true
    routeId?: true
    vehicleType?: true
    isAvailable?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RouteAvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteAvailability to aggregate.
     */
    where?: RouteAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteAvailabilities to fetch.
     */
    orderBy?: RouteAvailabilityOrderByWithRelationInput | RouteAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RouteAvailabilities
    **/
    _count?: true | RouteAvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteAvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteAvailabilityMaxAggregateInputType
  }

  export type GetRouteAvailabilityAggregateType<T extends RouteAvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateRouteAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRouteAvailability[P]>
      : GetScalarType<T[P], AggregateRouteAvailability[P]>
  }




  export type RouteAvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteAvailabilityWhereInput
    orderBy?: RouteAvailabilityOrderByWithAggregationInput | RouteAvailabilityOrderByWithAggregationInput[]
    by: RouteAvailabilityScalarFieldEnum[] | RouteAvailabilityScalarFieldEnum
    having?: RouteAvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteAvailabilityCountAggregateInputType | true
    _min?: RouteAvailabilityMinAggregateInputType
    _max?: RouteAvailabilityMaxAggregateInputType
  }

  export type RouteAvailabilityGroupByOutputType = {
    id: string
    routeId: string
    vehicleType: string
    isAvailable: boolean
    reason: string | null
    createdAt: Date
    updatedAt: Date
    _count: RouteAvailabilityCountAggregateOutputType | null
    _min: RouteAvailabilityMinAggregateOutputType | null
    _max: RouteAvailabilityMaxAggregateOutputType | null
  }

  type GetRouteAvailabilityGroupByPayload<T extends RouteAvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteAvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteAvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteAvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], RouteAvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type RouteAvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routeId?: boolean
    vehicleType?: boolean
    isAvailable?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeAvailability"]>



  export type RouteAvailabilitySelectScalar = {
    id?: boolean
    routeId?: boolean
    vehicleType?: boolean
    isAvailable?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RouteAvailabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "routeId" | "vehicleType" | "isAvailable" | "reason" | "createdAt" | "updatedAt", ExtArgs["result"]["routeAvailability"]>
  export type RouteAvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    route?: boolean | RouteDefaultArgs<ExtArgs>
  }

  export type $RouteAvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RouteAvailability"
    objects: {
      route: Prisma.$RoutePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      routeId: string
      vehicleType: string
      isAvailable: boolean
      reason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["routeAvailability"]>
    composites: {}
  }

  type RouteAvailabilityGetPayload<S extends boolean | null | undefined | RouteAvailabilityDefaultArgs> = $Result.GetResult<Prisma.$RouteAvailabilityPayload, S>

  type RouteAvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RouteAvailabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RouteAvailabilityCountAggregateInputType | true
    }

  export interface RouteAvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RouteAvailability'], meta: { name: 'RouteAvailability' } }
    /**
     * Find zero or one RouteAvailability that matches the filter.
     * @param {RouteAvailabilityFindUniqueArgs} args - Arguments to find a RouteAvailability
     * @example
     * // Get one RouteAvailability
     * const routeAvailability = await prisma.routeAvailability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteAvailabilityFindUniqueArgs>(args: SelectSubset<T, RouteAvailabilityFindUniqueArgs<ExtArgs>>): Prisma__RouteAvailabilityClient<$Result.GetResult<Prisma.$RouteAvailabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RouteAvailability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RouteAvailabilityFindUniqueOrThrowArgs} args - Arguments to find a RouteAvailability
     * @example
     * // Get one RouteAvailability
     * const routeAvailability = await prisma.routeAvailability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteAvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteAvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteAvailabilityClient<$Result.GetResult<Prisma.$RouteAvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteAvailability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAvailabilityFindFirstArgs} args - Arguments to find a RouteAvailability
     * @example
     * // Get one RouteAvailability
     * const routeAvailability = await prisma.routeAvailability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteAvailabilityFindFirstArgs>(args?: SelectSubset<T, RouteAvailabilityFindFirstArgs<ExtArgs>>): Prisma__RouteAvailabilityClient<$Result.GetResult<Prisma.$RouteAvailabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RouteAvailability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAvailabilityFindFirstOrThrowArgs} args - Arguments to find a RouteAvailability
     * @example
     * // Get one RouteAvailability
     * const routeAvailability = await prisma.routeAvailability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteAvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteAvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteAvailabilityClient<$Result.GetResult<Prisma.$RouteAvailabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RouteAvailabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RouteAvailabilities
     * const routeAvailabilities = await prisma.routeAvailability.findMany()
     * 
     * // Get first 10 RouteAvailabilities
     * const routeAvailabilities = await prisma.routeAvailability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeAvailabilityWithIdOnly = await prisma.routeAvailability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteAvailabilityFindManyArgs>(args?: SelectSubset<T, RouteAvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteAvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RouteAvailability.
     * @param {RouteAvailabilityCreateArgs} args - Arguments to create a RouteAvailability.
     * @example
     * // Create one RouteAvailability
     * const RouteAvailability = await prisma.routeAvailability.create({
     *   data: {
     *     // ... data to create a RouteAvailability
     *   }
     * })
     * 
     */
    create<T extends RouteAvailabilityCreateArgs>(args: SelectSubset<T, RouteAvailabilityCreateArgs<ExtArgs>>): Prisma__RouteAvailabilityClient<$Result.GetResult<Prisma.$RouteAvailabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RouteAvailabilities.
     * @param {RouteAvailabilityCreateManyArgs} args - Arguments to create many RouteAvailabilities.
     * @example
     * // Create many RouteAvailabilities
     * const routeAvailability = await prisma.routeAvailability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteAvailabilityCreateManyArgs>(args?: SelectSubset<T, RouteAvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RouteAvailability.
     * @param {RouteAvailabilityDeleteArgs} args - Arguments to delete one RouteAvailability.
     * @example
     * // Delete one RouteAvailability
     * const RouteAvailability = await prisma.routeAvailability.delete({
     *   where: {
     *     // ... filter to delete one RouteAvailability
     *   }
     * })
     * 
     */
    delete<T extends RouteAvailabilityDeleteArgs>(args: SelectSubset<T, RouteAvailabilityDeleteArgs<ExtArgs>>): Prisma__RouteAvailabilityClient<$Result.GetResult<Prisma.$RouteAvailabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RouteAvailability.
     * @param {RouteAvailabilityUpdateArgs} args - Arguments to update one RouteAvailability.
     * @example
     * // Update one RouteAvailability
     * const routeAvailability = await prisma.routeAvailability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteAvailabilityUpdateArgs>(args: SelectSubset<T, RouteAvailabilityUpdateArgs<ExtArgs>>): Prisma__RouteAvailabilityClient<$Result.GetResult<Prisma.$RouteAvailabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RouteAvailabilities.
     * @param {RouteAvailabilityDeleteManyArgs} args - Arguments to filter RouteAvailabilities to delete.
     * @example
     * // Delete a few RouteAvailabilities
     * const { count } = await prisma.routeAvailability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteAvailabilityDeleteManyArgs>(args?: SelectSubset<T, RouteAvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RouteAvailabilities
     * const routeAvailability = await prisma.routeAvailability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteAvailabilityUpdateManyArgs>(args: SelectSubset<T, RouteAvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RouteAvailability.
     * @param {RouteAvailabilityUpsertArgs} args - Arguments to update or create a RouteAvailability.
     * @example
     * // Update or create a RouteAvailability
     * const routeAvailability = await prisma.routeAvailability.upsert({
     *   create: {
     *     // ... data to create a RouteAvailability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RouteAvailability we want to update
     *   }
     * })
     */
    upsert<T extends RouteAvailabilityUpsertArgs>(args: SelectSubset<T, RouteAvailabilityUpsertArgs<ExtArgs>>): Prisma__RouteAvailabilityClient<$Result.GetResult<Prisma.$RouteAvailabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RouteAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAvailabilityCountArgs} args - Arguments to filter RouteAvailabilities to count.
     * @example
     * // Count the number of RouteAvailabilities
     * const count = await prisma.routeAvailability.count({
     *   where: {
     *     // ... the filter for the RouteAvailabilities we want to count
     *   }
     * })
    **/
    count<T extends RouteAvailabilityCountArgs>(
      args?: Subset<T, RouteAvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteAvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RouteAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteAvailabilityAggregateArgs>(args: Subset<T, RouteAvailabilityAggregateArgs>): Prisma.PrismaPromise<GetRouteAvailabilityAggregateType<T>>

    /**
     * Group by RouteAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteAvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteAvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteAvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: RouteAvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteAvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RouteAvailability model
   */
  readonly fields: RouteAvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RouteAvailability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteAvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    route<T extends RouteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RouteDefaultArgs<ExtArgs>>): Prisma__RouteClient<$Result.GetResult<Prisma.$RoutePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RouteAvailability model
   */
  interface RouteAvailabilityFieldRefs {
    readonly id: FieldRef<"RouteAvailability", 'String'>
    readonly routeId: FieldRef<"RouteAvailability", 'String'>
    readonly vehicleType: FieldRef<"RouteAvailability", 'String'>
    readonly isAvailable: FieldRef<"RouteAvailability", 'Boolean'>
    readonly reason: FieldRef<"RouteAvailability", 'String'>
    readonly createdAt: FieldRef<"RouteAvailability", 'DateTime'>
    readonly updatedAt: FieldRef<"RouteAvailability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RouteAvailability findUnique
   */
  export type RouteAvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteAvailability
     */
    select?: RouteAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteAvailability
     */
    omit?: RouteAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which RouteAvailability to fetch.
     */
    where: RouteAvailabilityWhereUniqueInput
  }

  /**
   * RouteAvailability findUniqueOrThrow
   */
  export type RouteAvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteAvailability
     */
    select?: RouteAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteAvailability
     */
    omit?: RouteAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which RouteAvailability to fetch.
     */
    where: RouteAvailabilityWhereUniqueInput
  }

  /**
   * RouteAvailability findFirst
   */
  export type RouteAvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteAvailability
     */
    select?: RouteAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteAvailability
     */
    omit?: RouteAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which RouteAvailability to fetch.
     */
    where?: RouteAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteAvailabilities to fetch.
     */
    orderBy?: RouteAvailabilityOrderByWithRelationInput | RouteAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteAvailabilities.
     */
    cursor?: RouteAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteAvailabilities.
     */
    distinct?: RouteAvailabilityScalarFieldEnum | RouteAvailabilityScalarFieldEnum[]
  }

  /**
   * RouteAvailability findFirstOrThrow
   */
  export type RouteAvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteAvailability
     */
    select?: RouteAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteAvailability
     */
    omit?: RouteAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which RouteAvailability to fetch.
     */
    where?: RouteAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteAvailabilities to fetch.
     */
    orderBy?: RouteAvailabilityOrderByWithRelationInput | RouteAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteAvailabilities.
     */
    cursor?: RouteAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteAvailabilities.
     */
    distinct?: RouteAvailabilityScalarFieldEnum | RouteAvailabilityScalarFieldEnum[]
  }

  /**
   * RouteAvailability findMany
   */
  export type RouteAvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteAvailability
     */
    select?: RouteAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteAvailability
     */
    omit?: RouteAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which RouteAvailabilities to fetch.
     */
    where?: RouteAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteAvailabilities to fetch.
     */
    orderBy?: RouteAvailabilityOrderByWithRelationInput | RouteAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RouteAvailabilities.
     */
    cursor?: RouteAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteAvailabilities.
     */
    skip?: number
    distinct?: RouteAvailabilityScalarFieldEnum | RouteAvailabilityScalarFieldEnum[]
  }

  /**
   * RouteAvailability create
   */
  export type RouteAvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteAvailability
     */
    select?: RouteAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteAvailability
     */
    omit?: RouteAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a RouteAvailability.
     */
    data: XOR<RouteAvailabilityCreateInput, RouteAvailabilityUncheckedCreateInput>
  }

  /**
   * RouteAvailability createMany
   */
  export type RouteAvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RouteAvailabilities.
     */
    data: RouteAvailabilityCreateManyInput | RouteAvailabilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RouteAvailability update
   */
  export type RouteAvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteAvailability
     */
    select?: RouteAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteAvailability
     */
    omit?: RouteAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a RouteAvailability.
     */
    data: XOR<RouteAvailabilityUpdateInput, RouteAvailabilityUncheckedUpdateInput>
    /**
     * Choose, which RouteAvailability to update.
     */
    where: RouteAvailabilityWhereUniqueInput
  }

  /**
   * RouteAvailability updateMany
   */
  export type RouteAvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RouteAvailabilities.
     */
    data: XOR<RouteAvailabilityUpdateManyMutationInput, RouteAvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which RouteAvailabilities to update
     */
    where?: RouteAvailabilityWhereInput
    /**
     * Limit how many RouteAvailabilities to update.
     */
    limit?: number
  }

  /**
   * RouteAvailability upsert
   */
  export type RouteAvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteAvailability
     */
    select?: RouteAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteAvailability
     */
    omit?: RouteAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteAvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the RouteAvailability to update in case it exists.
     */
    where: RouteAvailabilityWhereUniqueInput
    /**
     * In case the RouteAvailability found by the `where` argument doesn't exist, create a new RouteAvailability with this data.
     */
    create: XOR<RouteAvailabilityCreateInput, RouteAvailabilityUncheckedCreateInput>
    /**
     * In case the RouteAvailability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteAvailabilityUpdateInput, RouteAvailabilityUncheckedUpdateInput>
  }

  /**
   * RouteAvailability delete
   */
  export type RouteAvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteAvailability
     */
    select?: RouteAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteAvailability
     */
    omit?: RouteAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteAvailabilityInclude<ExtArgs> | null
    /**
     * Filter which RouteAvailability to delete.
     */
    where: RouteAvailabilityWhereUniqueInput
  }

  /**
   * RouteAvailability deleteMany
   */
  export type RouteAvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteAvailabilities to delete
     */
    where?: RouteAvailabilityWhereInput
    /**
     * Limit how many RouteAvailabilities to delete.
     */
    limit?: number
  }

  /**
   * RouteAvailability without action
   */
  export type RouteAvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteAvailability
     */
    select?: RouteAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the RouteAvailability
     */
    omit?: RouteAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteAvailabilityInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    fullName: 'fullName',
    email: 'email',
    phone: 'phone',
    employeeId: 'employeeId',
    designation: 'designation',
    department: 'department',
    manager: 'manager',
    approver: 'approver',
    password: 'password',
    pin: 'pin',
    authCode: 'authCode',
    status: 'status',
    needsPasswordChange: 'needsPasswordChange',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SystemSettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemSettingScalarFieldEnum = (typeof SystemSettingScalarFieldEnum)[keyof typeof SystemSettingScalarFieldEnum]


  export const SearchHistoryScalarFieldEnum: {
    id: 'id',
    search_query: 'search_query',
    latitude: 'latitude',
    longitude: 'longitude',
    search_count: 'search_count',
    first_searched: 'first_searched',
    last_searched: 'last_searched',
    user_type: 'user_type',
    device: 'device',
    is_successful: 'is_successful',
    converted_to_booking: 'converted_to_booking',
    booking_id: 'booking_id',
    user_id: 'user_id',
    session_id: 'session_id',
    source_page: 'source_page',
    search_category: 'search_category',
    estimated_distance: 'estimated_distance',
    estimated_duration: 'estimated_duration',
    peak_hour_search: 'peak_hour_search',
    region: 'region',
    city: 'city',
    state: 'state',
    search_completion_rate: 'search_completion_rate',
    user_agent: 'user_agent',
    ip_address: 'ip_address',
    referral_source: 'referral_source',
    time_to_result: 'time_to_result',
    competitor_price_check: 'competitor_price_check',
    potential_revenue: 'potential_revenue',
    seasonal_factor: 'seasonal_factor',
    market_demand_score: 'market_demand_score'
  };

  export type SearchHistoryScalarFieldEnum = (typeof SearchHistoryScalarFieldEnum)[keyof typeof SearchHistoryScalarFieldEnum]


  export const LocationDemandAnalyticsScalarFieldEnum: {
    id: 'id',
    region: 'region',
    city: 'city',
    state: 'state',
    total_searches: 'total_searches',
    successful_bookings: 'successful_bookings',
    revenue_generated: 'revenue_generated',
    peak_hours: 'peak_hours',
    popular_routes: 'popular_routes',
    average_fare: 'average_fare',
    demand_score: 'demand_score',
    updated_at: 'updated_at'
  };

  export type LocationDemandAnalyticsScalarFieldEnum = (typeof LocationDemandAnalyticsScalarFieldEnum)[keyof typeof LocationDemandAnalyticsScalarFieldEnum]


  export const PricingAnalyticsScalarFieldEnum: {
    id: 'id',
    route_hash: 'route_hash',
    base_price: 'base_price',
    surge_multiplier: 'surge_multiplier',
    peak_hour_rate: 'peak_hour_rate',
    off_peak_rate: 'off_peak_rate',
    competitor_price: 'competitor_price',
    success_rate: 'success_rate',
    last_updated: 'last_updated'
  };

  export type PricingAnalyticsScalarFieldEnum = (typeof PricingAnalyticsScalarFieldEnum)[keyof typeof PricingAnalyticsScalarFieldEnum]


  export const LocationScalarFieldEnum: {
    id: 'id',
    name: 'name',
    district: 'district',
    state: 'state',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LocationScalarFieldEnum = (typeof LocationScalarFieldEnum)[keyof typeof LocationScalarFieldEnum]


  export const RouteScalarFieldEnum: {
    id: 'id',
    originId: 'originId',
    destinationId: 'destinationId',
    directionType: 'directionType',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RouteScalarFieldEnum = (typeof RouteScalarFieldEnum)[keyof typeof RouteScalarFieldEnum]


  export const StopScalarFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    locationId: 'locationId',
    name: 'name',
    order: 'order',
    distanceKm: 'distanceKm',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StopScalarFieldEnum = (typeof StopScalarFieldEnum)[keyof typeof StopScalarFieldEnum]


  export const RouteFareScalarFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    vehicleType: 'vehicleType',
    pricingType: 'pricingType',
    baseFare: 'baseFare',
    perKmRate: 'perKmRate',
    perHourRate: 'perHourRate',
    nightCharge: 'nightCharge',
    hillCharge: 'hillCharge',
    waitingCharge: 'waitingCharge',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RouteFareScalarFieldEnum = (typeof RouteFareScalarFieldEnum)[keyof typeof RouteFareScalarFieldEnum]


  export const RouteAvailabilityScalarFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    vehicleType: 'vehicleType',
    isAvailable: 'isAvailable',
    reason: 'reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RouteAvailabilityScalarFieldEnum = (typeof RouteAvailabilityScalarFieldEnum)[keyof typeof RouteAvailabilityScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const UserOrderByRelevanceFieldEnum: {
    fullName: 'fullName',
    email: 'email',
    phone: 'phone',
    employeeId: 'employeeId',
    designation: 'designation',
    department: 'department',
    manager: 'manager',
    approver: 'approver',
    password: 'password',
    pin: 'pin',
    authCode: 'authCode',
    status: 'status',
    role: 'role'
  };

  export type UserOrderByRelevanceFieldEnum = (typeof UserOrderByRelevanceFieldEnum)[keyof typeof UserOrderByRelevanceFieldEnum]


  export const SystemSettingOrderByRelevanceFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value'
  };

  export type SystemSettingOrderByRelevanceFieldEnum = (typeof SystemSettingOrderByRelevanceFieldEnum)[keyof typeof SystemSettingOrderByRelevanceFieldEnum]


  export const SearchHistoryOrderByRelevanceFieldEnum: {
    id: 'id',
    search_query: 'search_query',
    user_type: 'user_type',
    device: 'device',
    booking_id: 'booking_id',
    session_id: 'session_id',
    source_page: 'source_page',
    search_category: 'search_category',
    region: 'region',
    city: 'city',
    state: 'state',
    user_agent: 'user_agent',
    ip_address: 'ip_address',
    referral_source: 'referral_source'
  };

  export type SearchHistoryOrderByRelevanceFieldEnum = (typeof SearchHistoryOrderByRelevanceFieldEnum)[keyof typeof SearchHistoryOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const LocationDemandAnalyticsOrderByRelevanceFieldEnum: {
    id: 'id',
    region: 'region',
    city: 'city',
    state: 'state'
  };

  export type LocationDemandAnalyticsOrderByRelevanceFieldEnum = (typeof LocationDemandAnalyticsOrderByRelevanceFieldEnum)[keyof typeof LocationDemandAnalyticsOrderByRelevanceFieldEnum]


  export const PricingAnalyticsOrderByRelevanceFieldEnum: {
    id: 'id',
    route_hash: 'route_hash'
  };

  export type PricingAnalyticsOrderByRelevanceFieldEnum = (typeof PricingAnalyticsOrderByRelevanceFieldEnum)[keyof typeof PricingAnalyticsOrderByRelevanceFieldEnum]


  export const LocationOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    district: 'district',
    state: 'state'
  };

  export type LocationOrderByRelevanceFieldEnum = (typeof LocationOrderByRelevanceFieldEnum)[keyof typeof LocationOrderByRelevanceFieldEnum]


  export const RouteOrderByRelevanceFieldEnum: {
    id: 'id',
    originId: 'originId',
    destinationId: 'destinationId',
    directionType: 'directionType'
  };

  export type RouteOrderByRelevanceFieldEnum = (typeof RouteOrderByRelevanceFieldEnum)[keyof typeof RouteOrderByRelevanceFieldEnum]


  export const StopOrderByRelevanceFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    locationId: 'locationId',
    name: 'name'
  };

  export type StopOrderByRelevanceFieldEnum = (typeof StopOrderByRelevanceFieldEnum)[keyof typeof StopOrderByRelevanceFieldEnum]


  export const RouteFareOrderByRelevanceFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    vehicleType: 'vehicleType',
    pricingType: 'pricingType'
  };

  export type RouteFareOrderByRelevanceFieldEnum = (typeof RouteFareOrderByRelevanceFieldEnum)[keyof typeof RouteFareOrderByRelevanceFieldEnum]


  export const RouteAvailabilityOrderByRelevanceFieldEnum: {
    id: 'id',
    routeId: 'routeId',
    vehicleType: 'vehicleType',
    reason: 'reason'
  };

  export type RouteAvailabilityOrderByRelevanceFieldEnum = (typeof RouteAvailabilityOrderByRelevanceFieldEnum)[keyof typeof RouteAvailabilityOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    fullName?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    employeeId?: StringFilter<"User"> | string
    designation?: StringFilter<"User"> | string
    department?: StringFilter<"User"> | string
    manager?: StringFilter<"User"> | string
    approver?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    pin?: StringNullableFilter<"User"> | string | null
    authCode?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    needsPasswordChange?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    searches?: SearchHistoryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    employeeId?: SortOrder
    designation?: SortOrder
    department?: SortOrder
    manager?: SortOrder
    approver?: SortOrder
    password?: SortOrderInput | SortOrder
    pin?: SortOrderInput | SortOrder
    authCode?: SortOrderInput | SortOrder
    status?: SortOrder
    needsPasswordChange?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    searches?: SearchHistoryOrderByRelationAggregateInput
    _relevance?: UserOrderByRelevanceInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    employeeId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullName?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    designation?: StringFilter<"User"> | string
    department?: StringFilter<"User"> | string
    manager?: StringFilter<"User"> | string
    approver?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    pin?: StringNullableFilter<"User"> | string | null
    authCode?: StringNullableFilter<"User"> | string | null
    status?: StringFilter<"User"> | string
    needsPasswordChange?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    searches?: SearchHistoryListRelationFilter
  }, "id" | "email" | "employeeId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    employeeId?: SortOrder
    designation?: SortOrder
    department?: SortOrder
    manager?: SortOrder
    approver?: SortOrder
    password?: SortOrderInput | SortOrder
    pin?: SortOrderInput | SortOrder
    authCode?: SortOrderInput | SortOrder
    status?: SortOrder
    needsPasswordChange?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    fullName?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    employeeId?: StringWithAggregatesFilter<"User"> | string
    designation?: StringWithAggregatesFilter<"User"> | string
    department?: StringWithAggregatesFilter<"User"> | string
    manager?: StringWithAggregatesFilter<"User"> | string
    approver?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    pin?: StringNullableWithAggregatesFilter<"User"> | string | null
    authCode?: StringNullableWithAggregatesFilter<"User"> | string | null
    status?: StringWithAggregatesFilter<"User"> | string
    needsPasswordChange?: BoolWithAggregatesFilter<"User"> | boolean
    role?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type SystemSettingWhereInput = {
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    id?: StringFilter<"SystemSetting"> | string
    key?: StringFilter<"SystemSetting"> | string
    value?: StringFilter<"SystemSetting"> | string
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }

  export type SystemSettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _relevance?: SystemSettingOrderByRelevanceInput
  }

  export type SystemSettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingWhereInput | SystemSettingWhereInput[]
    OR?: SystemSettingWhereInput[]
    NOT?: SystemSettingWhereInput | SystemSettingWhereInput[]
    value?: StringFilter<"SystemSetting"> | string
    createdAt?: DateTimeFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeFilter<"SystemSetting"> | Date | string
  }, "id" | "key">

  export type SystemSettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemSettingCountOrderByAggregateInput
    _max?: SystemSettingMaxOrderByAggregateInput
    _min?: SystemSettingMinOrderByAggregateInput
  }

  export type SystemSettingScalarWhereWithAggregatesInput = {
    AND?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    OR?: SystemSettingScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingScalarWhereWithAggregatesInput | SystemSettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSetting"> | string
    key?: StringWithAggregatesFilter<"SystemSetting"> | string
    value?: StringWithAggregatesFilter<"SystemSetting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemSetting"> | Date | string
  }

  export type SearchHistoryWhereInput = {
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    id?: StringFilter<"SearchHistory"> | string
    search_query?: StringFilter<"SearchHistory"> | string
    latitude?: FloatNullableFilter<"SearchHistory"> | number | null
    longitude?: FloatNullableFilter<"SearchHistory"> | number | null
    search_count?: IntFilter<"SearchHistory"> | number
    first_searched?: DateTimeFilter<"SearchHistory"> | Date | string
    last_searched?: DateTimeFilter<"SearchHistory"> | Date | string
    user_type?: StringFilter<"SearchHistory"> | string
    device?: StringNullableFilter<"SearchHistory"> | string | null
    is_successful?: BoolFilter<"SearchHistory"> | boolean
    converted_to_booking?: BoolFilter<"SearchHistory"> | boolean
    booking_id?: StringNullableFilter<"SearchHistory"> | string | null
    user_id?: IntNullableFilter<"SearchHistory"> | number | null
    session_id?: StringNullableFilter<"SearchHistory"> | string | null
    source_page?: StringNullableFilter<"SearchHistory"> | string | null
    search_category?: StringNullableFilter<"SearchHistory"> | string | null
    estimated_distance?: FloatNullableFilter<"SearchHistory"> | number | null
    estimated_duration?: IntNullableFilter<"SearchHistory"> | number | null
    peak_hour_search?: BoolFilter<"SearchHistory"> | boolean
    region?: StringNullableFilter<"SearchHistory"> | string | null
    city?: StringNullableFilter<"SearchHistory"> | string | null
    state?: StringNullableFilter<"SearchHistory"> | string | null
    search_completion_rate?: FloatNullableFilter<"SearchHistory"> | number | null
    user_agent?: StringNullableFilter<"SearchHistory"> | string | null
    ip_address?: StringNullableFilter<"SearchHistory"> | string | null
    referral_source?: StringNullableFilter<"SearchHistory"> | string | null
    time_to_result?: IntNullableFilter<"SearchHistory"> | number | null
    competitor_price_check?: BoolFilter<"SearchHistory"> | boolean
    potential_revenue?: FloatNullableFilter<"SearchHistory"> | number | null
    seasonal_factor?: FloatNullableFilter<"SearchHistory"> | number | null
    market_demand_score?: IntNullableFilter<"SearchHistory"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SearchHistoryOrderByWithRelationInput = {
    id?: SortOrder
    search_query?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    search_count?: SortOrder
    first_searched?: SortOrder
    last_searched?: SortOrder
    user_type?: SortOrder
    device?: SortOrderInput | SortOrder
    is_successful?: SortOrder
    converted_to_booking?: SortOrder
    booking_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    source_page?: SortOrderInput | SortOrder
    search_category?: SortOrderInput | SortOrder
    estimated_distance?: SortOrderInput | SortOrder
    estimated_duration?: SortOrderInput | SortOrder
    peak_hour_search?: SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    search_completion_rate?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    referral_source?: SortOrderInput | SortOrder
    time_to_result?: SortOrderInput | SortOrder
    competitor_price_check?: SortOrder
    potential_revenue?: SortOrderInput | SortOrder
    seasonal_factor?: SortOrderInput | SortOrder
    market_demand_score?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    _relevance?: SearchHistoryOrderByRelevanceInput
  }

  export type SearchHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    search_query?: StringFilter<"SearchHistory"> | string
    latitude?: FloatNullableFilter<"SearchHistory"> | number | null
    longitude?: FloatNullableFilter<"SearchHistory"> | number | null
    search_count?: IntFilter<"SearchHistory"> | number
    first_searched?: DateTimeFilter<"SearchHistory"> | Date | string
    last_searched?: DateTimeFilter<"SearchHistory"> | Date | string
    user_type?: StringFilter<"SearchHistory"> | string
    device?: StringNullableFilter<"SearchHistory"> | string | null
    is_successful?: BoolFilter<"SearchHistory"> | boolean
    converted_to_booking?: BoolFilter<"SearchHistory"> | boolean
    booking_id?: StringNullableFilter<"SearchHistory"> | string | null
    user_id?: IntNullableFilter<"SearchHistory"> | number | null
    session_id?: StringNullableFilter<"SearchHistory"> | string | null
    source_page?: StringNullableFilter<"SearchHistory"> | string | null
    search_category?: StringNullableFilter<"SearchHistory"> | string | null
    estimated_distance?: FloatNullableFilter<"SearchHistory"> | number | null
    estimated_duration?: IntNullableFilter<"SearchHistory"> | number | null
    peak_hour_search?: BoolFilter<"SearchHistory"> | boolean
    region?: StringNullableFilter<"SearchHistory"> | string | null
    city?: StringNullableFilter<"SearchHistory"> | string | null
    state?: StringNullableFilter<"SearchHistory"> | string | null
    search_completion_rate?: FloatNullableFilter<"SearchHistory"> | number | null
    user_agent?: StringNullableFilter<"SearchHistory"> | string | null
    ip_address?: StringNullableFilter<"SearchHistory"> | string | null
    referral_source?: StringNullableFilter<"SearchHistory"> | string | null
    time_to_result?: IntNullableFilter<"SearchHistory"> | number | null
    competitor_price_check?: BoolFilter<"SearchHistory"> | boolean
    potential_revenue?: FloatNullableFilter<"SearchHistory"> | number | null
    seasonal_factor?: FloatNullableFilter<"SearchHistory"> | number | null
    market_demand_score?: IntNullableFilter<"SearchHistory"> | number | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SearchHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    search_query?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    search_count?: SortOrder
    first_searched?: SortOrder
    last_searched?: SortOrder
    user_type?: SortOrder
    device?: SortOrderInput | SortOrder
    is_successful?: SortOrder
    converted_to_booking?: SortOrder
    booking_id?: SortOrderInput | SortOrder
    user_id?: SortOrderInput | SortOrder
    session_id?: SortOrderInput | SortOrder
    source_page?: SortOrderInput | SortOrder
    search_category?: SortOrderInput | SortOrder
    estimated_distance?: SortOrderInput | SortOrder
    estimated_duration?: SortOrderInput | SortOrder
    peak_hour_search?: SortOrder
    region?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    search_completion_rate?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    referral_source?: SortOrderInput | SortOrder
    time_to_result?: SortOrderInput | SortOrder
    competitor_price_check?: SortOrder
    potential_revenue?: SortOrderInput | SortOrder
    seasonal_factor?: SortOrderInput | SortOrder
    market_demand_score?: SortOrderInput | SortOrder
    _count?: SearchHistoryCountOrderByAggregateInput
    _avg?: SearchHistoryAvgOrderByAggregateInput
    _max?: SearchHistoryMaxOrderByAggregateInput
    _min?: SearchHistoryMinOrderByAggregateInput
    _sum?: SearchHistorySumOrderByAggregateInput
  }

  export type SearchHistoryScalarWhereWithAggregatesInput = {
    AND?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    OR?: SearchHistoryScalarWhereWithAggregatesInput[]
    NOT?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SearchHistory"> | string
    search_query?: StringWithAggregatesFilter<"SearchHistory"> | string
    latitude?: FloatNullableWithAggregatesFilter<"SearchHistory"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"SearchHistory"> | number | null
    search_count?: IntWithAggregatesFilter<"SearchHistory"> | number
    first_searched?: DateTimeWithAggregatesFilter<"SearchHistory"> | Date | string
    last_searched?: DateTimeWithAggregatesFilter<"SearchHistory"> | Date | string
    user_type?: StringWithAggregatesFilter<"SearchHistory"> | string
    device?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    is_successful?: BoolWithAggregatesFilter<"SearchHistory"> | boolean
    converted_to_booking?: BoolWithAggregatesFilter<"SearchHistory"> | boolean
    booking_id?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    user_id?: IntNullableWithAggregatesFilter<"SearchHistory"> | number | null
    session_id?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    source_page?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    search_category?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    estimated_distance?: FloatNullableWithAggregatesFilter<"SearchHistory"> | number | null
    estimated_duration?: IntNullableWithAggregatesFilter<"SearchHistory"> | number | null
    peak_hour_search?: BoolWithAggregatesFilter<"SearchHistory"> | boolean
    region?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    city?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    state?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    search_completion_rate?: FloatNullableWithAggregatesFilter<"SearchHistory"> | number | null
    user_agent?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    referral_source?: StringNullableWithAggregatesFilter<"SearchHistory"> | string | null
    time_to_result?: IntNullableWithAggregatesFilter<"SearchHistory"> | number | null
    competitor_price_check?: BoolWithAggregatesFilter<"SearchHistory"> | boolean
    potential_revenue?: FloatNullableWithAggregatesFilter<"SearchHistory"> | number | null
    seasonal_factor?: FloatNullableWithAggregatesFilter<"SearchHistory"> | number | null
    market_demand_score?: IntNullableWithAggregatesFilter<"SearchHistory"> | number | null
  }

  export type LocationDemandAnalyticsWhereInput = {
    AND?: LocationDemandAnalyticsWhereInput | LocationDemandAnalyticsWhereInput[]
    OR?: LocationDemandAnalyticsWhereInput[]
    NOT?: LocationDemandAnalyticsWhereInput | LocationDemandAnalyticsWhereInput[]
    id?: StringFilter<"LocationDemandAnalytics"> | string
    region?: StringFilter<"LocationDemandAnalytics"> | string
    city?: StringFilter<"LocationDemandAnalytics"> | string
    state?: StringFilter<"LocationDemandAnalytics"> | string
    total_searches?: IntFilter<"LocationDemandAnalytics"> | number
    successful_bookings?: IntFilter<"LocationDemandAnalytics"> | number
    revenue_generated?: FloatFilter<"LocationDemandAnalytics"> | number
    peak_hours?: JsonNullableFilter<"LocationDemandAnalytics">
    popular_routes?: JsonNullableFilter<"LocationDemandAnalytics">
    average_fare?: FloatNullableFilter<"LocationDemandAnalytics"> | number | null
    demand_score?: IntNullableFilter<"LocationDemandAnalytics"> | number | null
    updated_at?: DateTimeFilter<"LocationDemandAnalytics"> | Date | string
  }

  export type LocationDemandAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    region?: SortOrder
    city?: SortOrder
    state?: SortOrder
    total_searches?: SortOrder
    successful_bookings?: SortOrder
    revenue_generated?: SortOrder
    peak_hours?: SortOrderInput | SortOrder
    popular_routes?: SortOrderInput | SortOrder
    average_fare?: SortOrderInput | SortOrder
    demand_score?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    _relevance?: LocationDemandAnalyticsOrderByRelevanceInput
  }

  export type LocationDemandAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    region_city_state?: LocationDemandAnalyticsRegionCityStateCompoundUniqueInput
    AND?: LocationDemandAnalyticsWhereInput | LocationDemandAnalyticsWhereInput[]
    OR?: LocationDemandAnalyticsWhereInput[]
    NOT?: LocationDemandAnalyticsWhereInput | LocationDemandAnalyticsWhereInput[]
    region?: StringFilter<"LocationDemandAnalytics"> | string
    city?: StringFilter<"LocationDemandAnalytics"> | string
    state?: StringFilter<"LocationDemandAnalytics"> | string
    total_searches?: IntFilter<"LocationDemandAnalytics"> | number
    successful_bookings?: IntFilter<"LocationDemandAnalytics"> | number
    revenue_generated?: FloatFilter<"LocationDemandAnalytics"> | number
    peak_hours?: JsonNullableFilter<"LocationDemandAnalytics">
    popular_routes?: JsonNullableFilter<"LocationDemandAnalytics">
    average_fare?: FloatNullableFilter<"LocationDemandAnalytics"> | number | null
    demand_score?: IntNullableFilter<"LocationDemandAnalytics"> | number | null
    updated_at?: DateTimeFilter<"LocationDemandAnalytics"> | Date | string
  }, "id" | "region_city_state">

  export type LocationDemandAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    region?: SortOrder
    city?: SortOrder
    state?: SortOrder
    total_searches?: SortOrder
    successful_bookings?: SortOrder
    revenue_generated?: SortOrder
    peak_hours?: SortOrderInput | SortOrder
    popular_routes?: SortOrderInput | SortOrder
    average_fare?: SortOrderInput | SortOrder
    demand_score?: SortOrderInput | SortOrder
    updated_at?: SortOrder
    _count?: LocationDemandAnalyticsCountOrderByAggregateInput
    _avg?: LocationDemandAnalyticsAvgOrderByAggregateInput
    _max?: LocationDemandAnalyticsMaxOrderByAggregateInput
    _min?: LocationDemandAnalyticsMinOrderByAggregateInput
    _sum?: LocationDemandAnalyticsSumOrderByAggregateInput
  }

  export type LocationDemandAnalyticsScalarWhereWithAggregatesInput = {
    AND?: LocationDemandAnalyticsScalarWhereWithAggregatesInput | LocationDemandAnalyticsScalarWhereWithAggregatesInput[]
    OR?: LocationDemandAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: LocationDemandAnalyticsScalarWhereWithAggregatesInput | LocationDemandAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocationDemandAnalytics"> | string
    region?: StringWithAggregatesFilter<"LocationDemandAnalytics"> | string
    city?: StringWithAggregatesFilter<"LocationDemandAnalytics"> | string
    state?: StringWithAggregatesFilter<"LocationDemandAnalytics"> | string
    total_searches?: IntWithAggregatesFilter<"LocationDemandAnalytics"> | number
    successful_bookings?: IntWithAggregatesFilter<"LocationDemandAnalytics"> | number
    revenue_generated?: FloatWithAggregatesFilter<"LocationDemandAnalytics"> | number
    peak_hours?: JsonNullableWithAggregatesFilter<"LocationDemandAnalytics">
    popular_routes?: JsonNullableWithAggregatesFilter<"LocationDemandAnalytics">
    average_fare?: FloatNullableWithAggregatesFilter<"LocationDemandAnalytics"> | number | null
    demand_score?: IntNullableWithAggregatesFilter<"LocationDemandAnalytics"> | number | null
    updated_at?: DateTimeWithAggregatesFilter<"LocationDemandAnalytics"> | Date | string
  }

  export type PricingAnalyticsWhereInput = {
    AND?: PricingAnalyticsWhereInput | PricingAnalyticsWhereInput[]
    OR?: PricingAnalyticsWhereInput[]
    NOT?: PricingAnalyticsWhereInput | PricingAnalyticsWhereInput[]
    id?: StringFilter<"PricingAnalytics"> | string
    route_hash?: StringFilter<"PricingAnalytics"> | string
    base_price?: FloatFilter<"PricingAnalytics"> | number
    surge_multiplier?: FloatFilter<"PricingAnalytics"> | number
    peak_hour_rate?: FloatNullableFilter<"PricingAnalytics"> | number | null
    off_peak_rate?: FloatNullableFilter<"PricingAnalytics"> | number | null
    competitor_price?: FloatNullableFilter<"PricingAnalytics"> | number | null
    success_rate?: FloatNullableFilter<"PricingAnalytics"> | number | null
    last_updated?: DateTimeFilter<"PricingAnalytics"> | Date | string
  }

  export type PricingAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    route_hash?: SortOrder
    base_price?: SortOrder
    surge_multiplier?: SortOrder
    peak_hour_rate?: SortOrderInput | SortOrder
    off_peak_rate?: SortOrderInput | SortOrder
    competitor_price?: SortOrderInput | SortOrder
    success_rate?: SortOrderInput | SortOrder
    last_updated?: SortOrder
    _relevance?: PricingAnalyticsOrderByRelevanceInput
  }

  export type PricingAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    route_hash?: string
    AND?: PricingAnalyticsWhereInput | PricingAnalyticsWhereInput[]
    OR?: PricingAnalyticsWhereInput[]
    NOT?: PricingAnalyticsWhereInput | PricingAnalyticsWhereInput[]
    base_price?: FloatFilter<"PricingAnalytics"> | number
    surge_multiplier?: FloatFilter<"PricingAnalytics"> | number
    peak_hour_rate?: FloatNullableFilter<"PricingAnalytics"> | number | null
    off_peak_rate?: FloatNullableFilter<"PricingAnalytics"> | number | null
    competitor_price?: FloatNullableFilter<"PricingAnalytics"> | number | null
    success_rate?: FloatNullableFilter<"PricingAnalytics"> | number | null
    last_updated?: DateTimeFilter<"PricingAnalytics"> | Date | string
  }, "id" | "route_hash">

  export type PricingAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    route_hash?: SortOrder
    base_price?: SortOrder
    surge_multiplier?: SortOrder
    peak_hour_rate?: SortOrderInput | SortOrder
    off_peak_rate?: SortOrderInput | SortOrder
    competitor_price?: SortOrderInput | SortOrder
    success_rate?: SortOrderInput | SortOrder
    last_updated?: SortOrder
    _count?: PricingAnalyticsCountOrderByAggregateInput
    _avg?: PricingAnalyticsAvgOrderByAggregateInput
    _max?: PricingAnalyticsMaxOrderByAggregateInput
    _min?: PricingAnalyticsMinOrderByAggregateInput
    _sum?: PricingAnalyticsSumOrderByAggregateInput
  }

  export type PricingAnalyticsScalarWhereWithAggregatesInput = {
    AND?: PricingAnalyticsScalarWhereWithAggregatesInput | PricingAnalyticsScalarWhereWithAggregatesInput[]
    OR?: PricingAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: PricingAnalyticsScalarWhereWithAggregatesInput | PricingAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PricingAnalytics"> | string
    route_hash?: StringWithAggregatesFilter<"PricingAnalytics"> | string
    base_price?: FloatWithAggregatesFilter<"PricingAnalytics"> | number
    surge_multiplier?: FloatWithAggregatesFilter<"PricingAnalytics"> | number
    peak_hour_rate?: FloatNullableWithAggregatesFilter<"PricingAnalytics"> | number | null
    off_peak_rate?: FloatNullableWithAggregatesFilter<"PricingAnalytics"> | number | null
    competitor_price?: FloatNullableWithAggregatesFilter<"PricingAnalytics"> | number | null
    success_rate?: FloatNullableWithAggregatesFilter<"PricingAnalytics"> | number | null
    last_updated?: DateTimeWithAggregatesFilter<"PricingAnalytics"> | Date | string
  }

  export type LocationWhereInput = {
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    id?: StringFilter<"Location"> | string
    name?: StringFilter<"Location"> | string
    district?: StringFilter<"Location"> | string
    state?: StringFilter<"Location"> | string
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    routesFrom?: RouteListRelationFilter
    routesTo?: RouteListRelationFilter
    stops?: StopListRelationFilter
  }

  export type LocationOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    district?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    routesFrom?: RouteOrderByRelationAggregateInput
    routesTo?: RouteOrderByRelationAggregateInput
    stops?: StopOrderByRelationAggregateInput
    _relevance?: LocationOrderByRelevanceInput
  }

  export type LocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationWhereInput | LocationWhereInput[]
    OR?: LocationWhereInput[]
    NOT?: LocationWhereInput | LocationWhereInput[]
    name?: StringFilter<"Location"> | string
    district?: StringFilter<"Location"> | string
    state?: StringFilter<"Location"> | string
    isActive?: BoolFilter<"Location"> | boolean
    createdAt?: DateTimeFilter<"Location"> | Date | string
    updatedAt?: DateTimeFilter<"Location"> | Date | string
    routesFrom?: RouteListRelationFilter
    routesTo?: RouteListRelationFilter
    stops?: StopListRelationFilter
  }, "id">

  export type LocationOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    district?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LocationCountOrderByAggregateInput
    _max?: LocationMaxOrderByAggregateInput
    _min?: LocationMinOrderByAggregateInput
  }

  export type LocationScalarWhereWithAggregatesInput = {
    AND?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    OR?: LocationScalarWhereWithAggregatesInput[]
    NOT?: LocationScalarWhereWithAggregatesInput | LocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Location"> | string
    name?: StringWithAggregatesFilter<"Location"> | string
    district?: StringWithAggregatesFilter<"Location"> | string
    state?: StringWithAggregatesFilter<"Location"> | string
    isActive?: BoolWithAggregatesFilter<"Location"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Location"> | Date | string
  }

  export type RouteWhereInput = {
    AND?: RouteWhereInput | RouteWhereInput[]
    OR?: RouteWhereInput[]
    NOT?: RouteWhereInput | RouteWhereInput[]
    id?: StringFilter<"Route"> | string
    originId?: StringFilter<"Route"> | string
    destinationId?: StringFilter<"Route"> | string
    directionType?: StringFilter<"Route"> | string
    isActive?: BoolFilter<"Route"> | boolean
    createdAt?: DateTimeFilter<"Route"> | Date | string
    updatedAt?: DateTimeFilter<"Route"> | Date | string
    origin?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    destination?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    stops?: StopListRelationFilter
    fares?: RouteFareListRelationFilter
    availability?: RouteAvailabilityListRelationFilter
  }

  export type RouteOrderByWithRelationInput = {
    id?: SortOrder
    originId?: SortOrder
    destinationId?: SortOrder
    directionType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    origin?: LocationOrderByWithRelationInput
    destination?: LocationOrderByWithRelationInput
    stops?: StopOrderByRelationAggregateInput
    fares?: RouteFareOrderByRelationAggregateInput
    availability?: RouteAvailabilityOrderByRelationAggregateInput
    _relevance?: RouteOrderByRelevanceInput
  }

  export type RouteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RouteWhereInput | RouteWhereInput[]
    OR?: RouteWhereInput[]
    NOT?: RouteWhereInput | RouteWhereInput[]
    originId?: StringFilter<"Route"> | string
    destinationId?: StringFilter<"Route"> | string
    directionType?: StringFilter<"Route"> | string
    isActive?: BoolFilter<"Route"> | boolean
    createdAt?: DateTimeFilter<"Route"> | Date | string
    updatedAt?: DateTimeFilter<"Route"> | Date | string
    origin?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    destination?: XOR<LocationScalarRelationFilter, LocationWhereInput>
    stops?: StopListRelationFilter
    fares?: RouteFareListRelationFilter
    availability?: RouteAvailabilityListRelationFilter
  }, "id">

  export type RouteOrderByWithAggregationInput = {
    id?: SortOrder
    originId?: SortOrder
    destinationId?: SortOrder
    directionType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RouteCountOrderByAggregateInput
    _max?: RouteMaxOrderByAggregateInput
    _min?: RouteMinOrderByAggregateInput
  }

  export type RouteScalarWhereWithAggregatesInput = {
    AND?: RouteScalarWhereWithAggregatesInput | RouteScalarWhereWithAggregatesInput[]
    OR?: RouteScalarWhereWithAggregatesInput[]
    NOT?: RouteScalarWhereWithAggregatesInput | RouteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Route"> | string
    originId?: StringWithAggregatesFilter<"Route"> | string
    destinationId?: StringWithAggregatesFilter<"Route"> | string
    directionType?: StringWithAggregatesFilter<"Route"> | string
    isActive?: BoolWithAggregatesFilter<"Route"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Route"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Route"> | Date | string
  }

  export type StopWhereInput = {
    AND?: StopWhereInput | StopWhereInput[]
    OR?: StopWhereInput[]
    NOT?: StopWhereInput | StopWhereInput[]
    id?: StringFilter<"Stop"> | string
    routeId?: StringFilter<"Stop"> | string
    locationId?: StringFilter<"Stop"> | string
    name?: StringFilter<"Stop"> | string
    order?: IntFilter<"Stop"> | number
    distanceKm?: FloatNullableFilter<"Stop"> | number | null
    createdAt?: DateTimeFilter<"Stop"> | Date | string
    updatedAt?: DateTimeFilter<"Stop"> | Date | string
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }

  export type StopOrderByWithRelationInput = {
    id?: SortOrder
    routeId?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    distanceKm?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    route?: RouteOrderByWithRelationInput
    location?: LocationOrderByWithRelationInput
    _relevance?: StopOrderByRelevanceInput
  }

  export type StopWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StopWhereInput | StopWhereInput[]
    OR?: StopWhereInput[]
    NOT?: StopWhereInput | StopWhereInput[]
    routeId?: StringFilter<"Stop"> | string
    locationId?: StringFilter<"Stop"> | string
    name?: StringFilter<"Stop"> | string
    order?: IntFilter<"Stop"> | number
    distanceKm?: FloatNullableFilter<"Stop"> | number | null
    createdAt?: DateTimeFilter<"Stop"> | Date | string
    updatedAt?: DateTimeFilter<"Stop"> | Date | string
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
    location?: XOR<LocationScalarRelationFilter, LocationWhereInput>
  }, "id">

  export type StopOrderByWithAggregationInput = {
    id?: SortOrder
    routeId?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    distanceKm?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StopCountOrderByAggregateInput
    _avg?: StopAvgOrderByAggregateInput
    _max?: StopMaxOrderByAggregateInput
    _min?: StopMinOrderByAggregateInput
    _sum?: StopSumOrderByAggregateInput
  }

  export type StopScalarWhereWithAggregatesInput = {
    AND?: StopScalarWhereWithAggregatesInput | StopScalarWhereWithAggregatesInput[]
    OR?: StopScalarWhereWithAggregatesInput[]
    NOT?: StopScalarWhereWithAggregatesInput | StopScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stop"> | string
    routeId?: StringWithAggregatesFilter<"Stop"> | string
    locationId?: StringWithAggregatesFilter<"Stop"> | string
    name?: StringWithAggregatesFilter<"Stop"> | string
    order?: IntWithAggregatesFilter<"Stop"> | number
    distanceKm?: FloatNullableWithAggregatesFilter<"Stop"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Stop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Stop"> | Date | string
  }

  export type RouteFareWhereInput = {
    AND?: RouteFareWhereInput | RouteFareWhereInput[]
    OR?: RouteFareWhereInput[]
    NOT?: RouteFareWhereInput | RouteFareWhereInput[]
    id?: StringFilter<"RouteFare"> | string
    routeId?: StringFilter<"RouteFare"> | string
    vehicleType?: StringFilter<"RouteFare"> | string
    pricingType?: StringFilter<"RouteFare"> | string
    baseFare?: FloatFilter<"RouteFare"> | number
    perKmRate?: FloatNullableFilter<"RouteFare"> | number | null
    perHourRate?: FloatNullableFilter<"RouteFare"> | number | null
    nightCharge?: FloatNullableFilter<"RouteFare"> | number | null
    hillCharge?: FloatNullableFilter<"RouteFare"> | number | null
    waitingCharge?: FloatNullableFilter<"RouteFare"> | number | null
    createdAt?: DateTimeFilter<"RouteFare"> | Date | string
    updatedAt?: DateTimeFilter<"RouteFare"> | Date | string
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
  }

  export type RouteFareOrderByWithRelationInput = {
    id?: SortOrder
    routeId?: SortOrder
    vehicleType?: SortOrder
    pricingType?: SortOrder
    baseFare?: SortOrder
    perKmRate?: SortOrderInput | SortOrder
    perHourRate?: SortOrderInput | SortOrder
    nightCharge?: SortOrderInput | SortOrder
    hillCharge?: SortOrderInput | SortOrder
    waitingCharge?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    route?: RouteOrderByWithRelationInput
    _relevance?: RouteFareOrderByRelevanceInput
  }

  export type RouteFareWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RouteFareWhereInput | RouteFareWhereInput[]
    OR?: RouteFareWhereInput[]
    NOT?: RouteFareWhereInput | RouteFareWhereInput[]
    routeId?: StringFilter<"RouteFare"> | string
    vehicleType?: StringFilter<"RouteFare"> | string
    pricingType?: StringFilter<"RouteFare"> | string
    baseFare?: FloatFilter<"RouteFare"> | number
    perKmRate?: FloatNullableFilter<"RouteFare"> | number | null
    perHourRate?: FloatNullableFilter<"RouteFare"> | number | null
    nightCharge?: FloatNullableFilter<"RouteFare"> | number | null
    hillCharge?: FloatNullableFilter<"RouteFare"> | number | null
    waitingCharge?: FloatNullableFilter<"RouteFare"> | number | null
    createdAt?: DateTimeFilter<"RouteFare"> | Date | string
    updatedAt?: DateTimeFilter<"RouteFare"> | Date | string
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
  }, "id">

  export type RouteFareOrderByWithAggregationInput = {
    id?: SortOrder
    routeId?: SortOrder
    vehicleType?: SortOrder
    pricingType?: SortOrder
    baseFare?: SortOrder
    perKmRate?: SortOrderInput | SortOrder
    perHourRate?: SortOrderInput | SortOrder
    nightCharge?: SortOrderInput | SortOrder
    hillCharge?: SortOrderInput | SortOrder
    waitingCharge?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RouteFareCountOrderByAggregateInput
    _avg?: RouteFareAvgOrderByAggregateInput
    _max?: RouteFareMaxOrderByAggregateInput
    _min?: RouteFareMinOrderByAggregateInput
    _sum?: RouteFareSumOrderByAggregateInput
  }

  export type RouteFareScalarWhereWithAggregatesInput = {
    AND?: RouteFareScalarWhereWithAggregatesInput | RouteFareScalarWhereWithAggregatesInput[]
    OR?: RouteFareScalarWhereWithAggregatesInput[]
    NOT?: RouteFareScalarWhereWithAggregatesInput | RouteFareScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RouteFare"> | string
    routeId?: StringWithAggregatesFilter<"RouteFare"> | string
    vehicleType?: StringWithAggregatesFilter<"RouteFare"> | string
    pricingType?: StringWithAggregatesFilter<"RouteFare"> | string
    baseFare?: FloatWithAggregatesFilter<"RouteFare"> | number
    perKmRate?: FloatNullableWithAggregatesFilter<"RouteFare"> | number | null
    perHourRate?: FloatNullableWithAggregatesFilter<"RouteFare"> | number | null
    nightCharge?: FloatNullableWithAggregatesFilter<"RouteFare"> | number | null
    hillCharge?: FloatNullableWithAggregatesFilter<"RouteFare"> | number | null
    waitingCharge?: FloatNullableWithAggregatesFilter<"RouteFare"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"RouteFare"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RouteFare"> | Date | string
  }

  export type RouteAvailabilityWhereInput = {
    AND?: RouteAvailabilityWhereInput | RouteAvailabilityWhereInput[]
    OR?: RouteAvailabilityWhereInput[]
    NOT?: RouteAvailabilityWhereInput | RouteAvailabilityWhereInput[]
    id?: StringFilter<"RouteAvailability"> | string
    routeId?: StringFilter<"RouteAvailability"> | string
    vehicleType?: StringFilter<"RouteAvailability"> | string
    isAvailable?: BoolFilter<"RouteAvailability"> | boolean
    reason?: StringNullableFilter<"RouteAvailability"> | string | null
    createdAt?: DateTimeFilter<"RouteAvailability"> | Date | string
    updatedAt?: DateTimeFilter<"RouteAvailability"> | Date | string
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
  }

  export type RouteAvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    routeId?: SortOrder
    vehicleType?: SortOrder
    isAvailable?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    route?: RouteOrderByWithRelationInput
    _relevance?: RouteAvailabilityOrderByRelevanceInput
  }

  export type RouteAvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RouteAvailabilityWhereInput | RouteAvailabilityWhereInput[]
    OR?: RouteAvailabilityWhereInput[]
    NOT?: RouteAvailabilityWhereInput | RouteAvailabilityWhereInput[]
    routeId?: StringFilter<"RouteAvailability"> | string
    vehicleType?: StringFilter<"RouteAvailability"> | string
    isAvailable?: BoolFilter<"RouteAvailability"> | boolean
    reason?: StringNullableFilter<"RouteAvailability"> | string | null
    createdAt?: DateTimeFilter<"RouteAvailability"> | Date | string
    updatedAt?: DateTimeFilter<"RouteAvailability"> | Date | string
    route?: XOR<RouteScalarRelationFilter, RouteWhereInput>
  }, "id">

  export type RouteAvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    routeId?: SortOrder
    vehicleType?: SortOrder
    isAvailable?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RouteAvailabilityCountOrderByAggregateInput
    _max?: RouteAvailabilityMaxOrderByAggregateInput
    _min?: RouteAvailabilityMinOrderByAggregateInput
  }

  export type RouteAvailabilityScalarWhereWithAggregatesInput = {
    AND?: RouteAvailabilityScalarWhereWithAggregatesInput | RouteAvailabilityScalarWhereWithAggregatesInput[]
    OR?: RouteAvailabilityScalarWhereWithAggregatesInput[]
    NOT?: RouteAvailabilityScalarWhereWithAggregatesInput | RouteAvailabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RouteAvailability"> | string
    routeId?: StringWithAggregatesFilter<"RouteAvailability"> | string
    vehicleType?: StringWithAggregatesFilter<"RouteAvailability"> | string
    isAvailable?: BoolWithAggregatesFilter<"RouteAvailability"> | boolean
    reason?: StringNullableWithAggregatesFilter<"RouteAvailability"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RouteAvailability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RouteAvailability"> | Date | string
  }

  export type UserCreateInput = {
    fullName: string
    email: string
    phone: string
    employeeId: string
    designation: string
    department: string
    manager: string
    approver: string
    password?: string | null
    pin?: string | null
    authCode?: string | null
    status?: string
    needsPasswordChange?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    searches?: SearchHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    fullName: string
    email: string
    phone: string
    employeeId: string
    designation: string
    department: string
    manager: string
    approver: string
    password?: string | null
    pin?: string | null
    authCode?: string | null
    status?: string
    needsPasswordChange?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    searches?: SearchHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    approver?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    needsPasswordChange?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    searches?: SearchHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    approver?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    needsPasswordChange?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    searches?: SearchHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    fullName: string
    email: string
    phone: string
    employeeId: string
    designation: string
    department: string
    manager: string
    approver: string
    password?: string | null
    pin?: string | null
    authCode?: string | null
    status?: string
    needsPasswordChange?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    approver?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    needsPasswordChange?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    approver?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    needsPasswordChange?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateInput = {
    id?: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingCreateManyInput = {
    id?: string
    key: string
    value: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemSettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryCreateInput = {
    id?: string
    search_query: string
    latitude?: number | null
    longitude?: number | null
    search_count?: number
    first_searched?: Date | string
    last_searched?: Date | string
    user_type?: string
    device?: string | null
    is_successful?: boolean
    converted_to_booking?: boolean
    booking_id?: string | null
    session_id?: string | null
    source_page?: string | null
    search_category?: string | null
    estimated_distance?: number | null
    estimated_duration?: number | null
    peak_hour_search?: boolean
    region?: string | null
    city?: string | null
    state?: string | null
    search_completion_rate?: number | null
    user_agent?: string | null
    ip_address?: string | null
    referral_source?: string | null
    time_to_result?: number | null
    competitor_price_check?: boolean
    potential_revenue?: number | null
    seasonal_factor?: number | null
    market_demand_score?: number | null
    user?: UserCreateNestedOneWithoutSearchesInput
  }

  export type SearchHistoryUncheckedCreateInput = {
    id?: string
    search_query: string
    latitude?: number | null
    longitude?: number | null
    search_count?: number
    first_searched?: Date | string
    last_searched?: Date | string
    user_type?: string
    device?: string | null
    is_successful?: boolean
    converted_to_booking?: boolean
    booking_id?: string | null
    user_id?: number | null
    session_id?: string | null
    source_page?: string | null
    search_category?: string | null
    estimated_distance?: number | null
    estimated_duration?: number | null
    peak_hour_search?: boolean
    region?: string | null
    city?: string | null
    state?: string | null
    search_completion_rate?: number | null
    user_agent?: string | null
    ip_address?: string | null
    referral_source?: string | null
    time_to_result?: number | null
    competitor_price_check?: boolean
    potential_revenue?: number | null
    seasonal_factor?: number | null
    market_demand_score?: number | null
  }

  export type SearchHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    search_query?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    search_count?: IntFieldUpdateOperationsInput | number
    first_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    last_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    user_type?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    is_successful?: BoolFieldUpdateOperationsInput | boolean
    converted_to_booking?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    source_page?: NullableStringFieldUpdateOperationsInput | string | null
    search_category?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_duration?: NullableIntFieldUpdateOperationsInput | number | null
    peak_hour_search?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    search_completion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source?: NullableStringFieldUpdateOperationsInput | string | null
    time_to_result?: NullableIntFieldUpdateOperationsInput | number | null
    competitor_price_check?: BoolFieldUpdateOperationsInput | boolean
    potential_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    seasonal_factor?: NullableFloatFieldUpdateOperationsInput | number | null
    market_demand_score?: NullableIntFieldUpdateOperationsInput | number | null
    user?: UserUpdateOneWithoutSearchesNestedInput
  }

  export type SearchHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    search_query?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    search_count?: IntFieldUpdateOperationsInput | number
    first_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    last_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    user_type?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    is_successful?: BoolFieldUpdateOperationsInput | boolean
    converted_to_booking?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    source_page?: NullableStringFieldUpdateOperationsInput | string | null
    search_category?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_duration?: NullableIntFieldUpdateOperationsInput | number | null
    peak_hour_search?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    search_completion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source?: NullableStringFieldUpdateOperationsInput | string | null
    time_to_result?: NullableIntFieldUpdateOperationsInput | number | null
    competitor_price_check?: BoolFieldUpdateOperationsInput | boolean
    potential_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    seasonal_factor?: NullableFloatFieldUpdateOperationsInput | number | null
    market_demand_score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SearchHistoryCreateManyInput = {
    id?: string
    search_query: string
    latitude?: number | null
    longitude?: number | null
    search_count?: number
    first_searched?: Date | string
    last_searched?: Date | string
    user_type?: string
    device?: string | null
    is_successful?: boolean
    converted_to_booking?: boolean
    booking_id?: string | null
    user_id?: number | null
    session_id?: string | null
    source_page?: string | null
    search_category?: string | null
    estimated_distance?: number | null
    estimated_duration?: number | null
    peak_hour_search?: boolean
    region?: string | null
    city?: string | null
    state?: string | null
    search_completion_rate?: number | null
    user_agent?: string | null
    ip_address?: string | null
    referral_source?: string | null
    time_to_result?: number | null
    competitor_price_check?: boolean
    potential_revenue?: number | null
    seasonal_factor?: number | null
    market_demand_score?: number | null
  }

  export type SearchHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    search_query?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    search_count?: IntFieldUpdateOperationsInput | number
    first_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    last_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    user_type?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    is_successful?: BoolFieldUpdateOperationsInput | boolean
    converted_to_booking?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    source_page?: NullableStringFieldUpdateOperationsInput | string | null
    search_category?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_duration?: NullableIntFieldUpdateOperationsInput | number | null
    peak_hour_search?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    search_completion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source?: NullableStringFieldUpdateOperationsInput | string | null
    time_to_result?: NullableIntFieldUpdateOperationsInput | number | null
    competitor_price_check?: BoolFieldUpdateOperationsInput | boolean
    potential_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    seasonal_factor?: NullableFloatFieldUpdateOperationsInput | number | null
    market_demand_score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SearchHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    search_query?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    search_count?: IntFieldUpdateOperationsInput | number
    first_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    last_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    user_type?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    is_successful?: BoolFieldUpdateOperationsInput | boolean
    converted_to_booking?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: NullableIntFieldUpdateOperationsInput | number | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    source_page?: NullableStringFieldUpdateOperationsInput | string | null
    search_category?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_duration?: NullableIntFieldUpdateOperationsInput | number | null
    peak_hour_search?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    search_completion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source?: NullableStringFieldUpdateOperationsInput | string | null
    time_to_result?: NullableIntFieldUpdateOperationsInput | number | null
    competitor_price_check?: BoolFieldUpdateOperationsInput | boolean
    potential_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    seasonal_factor?: NullableFloatFieldUpdateOperationsInput | number | null
    market_demand_score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LocationDemandAnalyticsCreateInput = {
    id?: string
    region: string
    city: string
    state: string
    total_searches?: number
    successful_bookings?: number
    revenue_generated?: number
    peak_hours?: NullableJsonNullValueInput | InputJsonValue
    popular_routes?: NullableJsonNullValueInput | InputJsonValue
    average_fare?: number | null
    demand_score?: number | null
    updated_at?: Date | string
  }

  export type LocationDemandAnalyticsUncheckedCreateInput = {
    id?: string
    region: string
    city: string
    state: string
    total_searches?: number
    successful_bookings?: number
    revenue_generated?: number
    peak_hours?: NullableJsonNullValueInput | InputJsonValue
    popular_routes?: NullableJsonNullValueInput | InputJsonValue
    average_fare?: number | null
    demand_score?: number | null
    updated_at?: Date | string
  }

  export type LocationDemandAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    total_searches?: IntFieldUpdateOperationsInput | number
    successful_bookings?: IntFieldUpdateOperationsInput | number
    revenue_generated?: FloatFieldUpdateOperationsInput | number
    peak_hours?: NullableJsonNullValueInput | InputJsonValue
    popular_routes?: NullableJsonNullValueInput | InputJsonValue
    average_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    demand_score?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationDemandAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    total_searches?: IntFieldUpdateOperationsInput | number
    successful_bookings?: IntFieldUpdateOperationsInput | number
    revenue_generated?: FloatFieldUpdateOperationsInput | number
    peak_hours?: NullableJsonNullValueInput | InputJsonValue
    popular_routes?: NullableJsonNullValueInput | InputJsonValue
    average_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    demand_score?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationDemandAnalyticsCreateManyInput = {
    id?: string
    region: string
    city: string
    state: string
    total_searches?: number
    successful_bookings?: number
    revenue_generated?: number
    peak_hours?: NullableJsonNullValueInput | InputJsonValue
    popular_routes?: NullableJsonNullValueInput | InputJsonValue
    average_fare?: number | null
    demand_score?: number | null
    updated_at?: Date | string
  }

  export type LocationDemandAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    total_searches?: IntFieldUpdateOperationsInput | number
    successful_bookings?: IntFieldUpdateOperationsInput | number
    revenue_generated?: FloatFieldUpdateOperationsInput | number
    peak_hours?: NullableJsonNullValueInput | InputJsonValue
    popular_routes?: NullableJsonNullValueInput | InputJsonValue
    average_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    demand_score?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationDemandAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    region?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    total_searches?: IntFieldUpdateOperationsInput | number
    successful_bookings?: IntFieldUpdateOperationsInput | number
    revenue_generated?: FloatFieldUpdateOperationsInput | number
    peak_hours?: NullableJsonNullValueInput | InputJsonValue
    popular_routes?: NullableJsonNullValueInput | InputJsonValue
    average_fare?: NullableFloatFieldUpdateOperationsInput | number | null
    demand_score?: NullableIntFieldUpdateOperationsInput | number | null
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingAnalyticsCreateInput = {
    id?: string
    route_hash: string
    base_price: number
    surge_multiplier?: number
    peak_hour_rate?: number | null
    off_peak_rate?: number | null
    competitor_price?: number | null
    success_rate?: number | null
    last_updated?: Date | string
  }

  export type PricingAnalyticsUncheckedCreateInput = {
    id?: string
    route_hash: string
    base_price: number
    surge_multiplier?: number
    peak_hour_rate?: number | null
    off_peak_rate?: number | null
    competitor_price?: number | null
    success_rate?: number | null
    last_updated?: Date | string
  }

  export type PricingAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_hash?: StringFieldUpdateOperationsInput | string
    base_price?: FloatFieldUpdateOperationsInput | number
    surge_multiplier?: FloatFieldUpdateOperationsInput | number
    peak_hour_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    off_peak_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    competitor_price?: NullableFloatFieldUpdateOperationsInput | number | null
    success_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_hash?: StringFieldUpdateOperationsInput | string
    base_price?: FloatFieldUpdateOperationsInput | number
    surge_multiplier?: FloatFieldUpdateOperationsInput | number
    peak_hour_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    off_peak_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    competitor_price?: NullableFloatFieldUpdateOperationsInput | number | null
    success_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingAnalyticsCreateManyInput = {
    id?: string
    route_hash: string
    base_price: number
    surge_multiplier?: number
    peak_hour_rate?: number | null
    off_peak_rate?: number | null
    competitor_price?: number | null
    success_rate?: number | null
    last_updated?: Date | string
  }

  export type PricingAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_hash?: StringFieldUpdateOperationsInput | string
    base_price?: FloatFieldUpdateOperationsInput | number
    surge_multiplier?: FloatFieldUpdateOperationsInput | number
    peak_hour_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    off_peak_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    competitor_price?: NullableFloatFieldUpdateOperationsInput | number | null
    success_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PricingAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    route_hash?: StringFieldUpdateOperationsInput | string
    base_price?: FloatFieldUpdateOperationsInput | number
    surge_multiplier?: FloatFieldUpdateOperationsInput | number
    peak_hour_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    off_peak_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    competitor_price?: NullableFloatFieldUpdateOperationsInput | number | null
    success_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    last_updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationCreateInput = {
    id?: string
    name: string
    district: string
    state?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    routesFrom?: RouteCreateNestedManyWithoutOriginInput
    routesTo?: RouteCreateNestedManyWithoutDestinationInput
    stops?: StopCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateInput = {
    id?: string
    name: string
    district: string
    state?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    routesFrom?: RouteUncheckedCreateNestedManyWithoutOriginInput
    routesTo?: RouteUncheckedCreateNestedManyWithoutDestinationInput
    stops?: StopUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routesFrom?: RouteUpdateManyWithoutOriginNestedInput
    routesTo?: RouteUpdateManyWithoutDestinationNestedInput
    stops?: StopUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routesFrom?: RouteUncheckedUpdateManyWithoutOriginNestedInput
    routesTo?: RouteUncheckedUpdateManyWithoutDestinationNestedInput
    stops?: StopUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationCreateManyInput = {
    id?: string
    name: string
    district: string
    state?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteCreateInput = {
    id?: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    origin: LocationCreateNestedOneWithoutRoutesFromInput
    destination: LocationCreateNestedOneWithoutRoutesToInput
    stops?: StopCreateNestedManyWithoutRouteInput
    fares?: RouteFareCreateNestedManyWithoutRouteInput
    availability?: RouteAvailabilityCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateInput = {
    id?: string
    originId: string
    destinationId: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stops?: StopUncheckedCreateNestedManyWithoutRouteInput
    fares?: RouteFareUncheckedCreateNestedManyWithoutRouteInput
    availability?: RouteAvailabilityUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: LocationUpdateOneRequiredWithoutRoutesFromNestedInput
    destination?: LocationUpdateOneRequiredWithoutRoutesToNestedInput
    stops?: StopUpdateManyWithoutRouteNestedInput
    fares?: RouteFareUpdateManyWithoutRouteNestedInput
    availability?: RouteAvailabilityUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    originId?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stops?: StopUncheckedUpdateManyWithoutRouteNestedInput
    fares?: RouteFareUncheckedUpdateManyWithoutRouteNestedInput
    availability?: RouteAvailabilityUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteCreateManyInput = {
    id?: string
    originId: string
    destinationId: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    originId?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopCreateInput = {
    id?: string
    name: string
    order: number
    distanceKm?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    route: RouteCreateNestedOneWithoutStopsInput
    location: LocationCreateNestedOneWithoutStopsInput
  }

  export type StopUncheckedCreateInput = {
    id?: string
    routeId: string
    locationId: string
    name: string
    order: number
    distanceKm?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StopUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    route?: RouteUpdateOneRequiredWithoutStopsNestedInput
    location?: LocationUpdateOneRequiredWithoutStopsNestedInput
  }

  export type StopUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopCreateManyInput = {
    id?: string
    routeId: string
    locationId: string
    name: string
    order: number
    distanceKm?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StopUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteFareCreateInput = {
    id?: string
    vehicleType: string
    pricingType: string
    baseFare: number
    perKmRate?: number | null
    perHourRate?: number | null
    nightCharge?: number | null
    hillCharge?: number | null
    waitingCharge?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    route: RouteCreateNestedOneWithoutFaresInput
  }

  export type RouteFareUncheckedCreateInput = {
    id?: string
    routeId: string
    vehicleType: string
    pricingType: string
    baseFare: number
    perKmRate?: number | null
    perHourRate?: number | null
    nightCharge?: number | null
    hillCharge?: number | null
    waitingCharge?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteFareUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    pricingType?: StringFieldUpdateOperationsInput | string
    baseFare?: FloatFieldUpdateOperationsInput | number
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    perHourRate?: NullableFloatFieldUpdateOperationsInput | number | null
    nightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    hillCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    waitingCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    route?: RouteUpdateOneRequiredWithoutFaresNestedInput
  }

  export type RouteFareUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    pricingType?: StringFieldUpdateOperationsInput | string
    baseFare?: FloatFieldUpdateOperationsInput | number
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    perHourRate?: NullableFloatFieldUpdateOperationsInput | number | null
    nightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    hillCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    waitingCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteFareCreateManyInput = {
    id?: string
    routeId: string
    vehicleType: string
    pricingType: string
    baseFare: number
    perKmRate?: number | null
    perHourRate?: number | null
    nightCharge?: number | null
    hillCharge?: number | null
    waitingCharge?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteFareUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    pricingType?: StringFieldUpdateOperationsInput | string
    baseFare?: FloatFieldUpdateOperationsInput | number
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    perHourRate?: NullableFloatFieldUpdateOperationsInput | number | null
    nightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    hillCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    waitingCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteFareUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    pricingType?: StringFieldUpdateOperationsInput | string
    baseFare?: FloatFieldUpdateOperationsInput | number
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    perHourRate?: NullableFloatFieldUpdateOperationsInput | number | null
    nightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    hillCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    waitingCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteAvailabilityCreateInput = {
    id?: string
    vehicleType: string
    isAvailable?: boolean
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    route: RouteCreateNestedOneWithoutAvailabilityInput
  }

  export type RouteAvailabilityUncheckedCreateInput = {
    id?: string
    routeId: string
    vehicleType: string
    isAvailable?: boolean
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteAvailabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    route?: RouteUpdateOneRequiredWithoutAvailabilityNestedInput
  }

  export type RouteAvailabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteAvailabilityCreateManyInput = {
    id?: string
    routeId: string
    vehicleType: string
    isAvailable?: boolean
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteAvailabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteAvailabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SearchHistoryListRelationFilter = {
    every?: SearchHistoryWhereInput
    some?: SearchHistoryWhereInput
    none?: SearchHistoryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type SearchHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelevanceInput = {
    fields: UserOrderByRelevanceFieldEnum | UserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    employeeId?: SortOrder
    designation?: SortOrder
    department?: SortOrder
    manager?: SortOrder
    approver?: SortOrder
    password?: SortOrder
    pin?: SortOrder
    authCode?: SortOrder
    status?: SortOrder
    needsPasswordChange?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    employeeId?: SortOrder
    designation?: SortOrder
    department?: SortOrder
    manager?: SortOrder
    approver?: SortOrder
    password?: SortOrder
    pin?: SortOrder
    authCode?: SortOrder
    status?: SortOrder
    needsPasswordChange?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    employeeId?: SortOrder
    designation?: SortOrder
    department?: SortOrder
    manager?: SortOrder
    approver?: SortOrder
    password?: SortOrder
    pin?: SortOrder
    authCode?: SortOrder
    status?: SortOrder
    needsPasswordChange?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type SystemSettingOrderByRelevanceInput = {
    fields: SystemSettingOrderByRelevanceFieldEnum | SystemSettingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SystemSettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemSettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SearchHistoryOrderByRelevanceInput = {
    fields: SearchHistoryOrderByRelevanceFieldEnum | SearchHistoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SearchHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    search_query?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    search_count?: SortOrder
    first_searched?: SortOrder
    last_searched?: SortOrder
    user_type?: SortOrder
    device?: SortOrder
    is_successful?: SortOrder
    converted_to_booking?: SortOrder
    booking_id?: SortOrder
    user_id?: SortOrder
    session_id?: SortOrder
    source_page?: SortOrder
    search_category?: SortOrder
    estimated_distance?: SortOrder
    estimated_duration?: SortOrder
    peak_hour_search?: SortOrder
    region?: SortOrder
    city?: SortOrder
    state?: SortOrder
    search_completion_rate?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    referral_source?: SortOrder
    time_to_result?: SortOrder
    competitor_price_check?: SortOrder
    potential_revenue?: SortOrder
    seasonal_factor?: SortOrder
    market_demand_score?: SortOrder
  }

  export type SearchHistoryAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    search_count?: SortOrder
    user_id?: SortOrder
    estimated_distance?: SortOrder
    estimated_duration?: SortOrder
    search_completion_rate?: SortOrder
    time_to_result?: SortOrder
    potential_revenue?: SortOrder
    seasonal_factor?: SortOrder
    market_demand_score?: SortOrder
  }

  export type SearchHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    search_query?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    search_count?: SortOrder
    first_searched?: SortOrder
    last_searched?: SortOrder
    user_type?: SortOrder
    device?: SortOrder
    is_successful?: SortOrder
    converted_to_booking?: SortOrder
    booking_id?: SortOrder
    user_id?: SortOrder
    session_id?: SortOrder
    source_page?: SortOrder
    search_category?: SortOrder
    estimated_distance?: SortOrder
    estimated_duration?: SortOrder
    peak_hour_search?: SortOrder
    region?: SortOrder
    city?: SortOrder
    state?: SortOrder
    search_completion_rate?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    referral_source?: SortOrder
    time_to_result?: SortOrder
    competitor_price_check?: SortOrder
    potential_revenue?: SortOrder
    seasonal_factor?: SortOrder
    market_demand_score?: SortOrder
  }

  export type SearchHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    search_query?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    search_count?: SortOrder
    first_searched?: SortOrder
    last_searched?: SortOrder
    user_type?: SortOrder
    device?: SortOrder
    is_successful?: SortOrder
    converted_to_booking?: SortOrder
    booking_id?: SortOrder
    user_id?: SortOrder
    session_id?: SortOrder
    source_page?: SortOrder
    search_category?: SortOrder
    estimated_distance?: SortOrder
    estimated_duration?: SortOrder
    peak_hour_search?: SortOrder
    region?: SortOrder
    city?: SortOrder
    state?: SortOrder
    search_completion_rate?: SortOrder
    user_agent?: SortOrder
    ip_address?: SortOrder
    referral_source?: SortOrder
    time_to_result?: SortOrder
    competitor_price_check?: SortOrder
    potential_revenue?: SortOrder
    seasonal_factor?: SortOrder
    market_demand_score?: SortOrder
  }

  export type SearchHistorySumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    search_count?: SortOrder
    user_id?: SortOrder
    estimated_distance?: SortOrder
    estimated_duration?: SortOrder
    search_completion_rate?: SortOrder
    time_to_result?: SortOrder
    potential_revenue?: SortOrder
    seasonal_factor?: SortOrder
    market_demand_score?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type LocationDemandAnalyticsOrderByRelevanceInput = {
    fields: LocationDemandAnalyticsOrderByRelevanceFieldEnum | LocationDemandAnalyticsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LocationDemandAnalyticsRegionCityStateCompoundUniqueInput = {
    region: string
    city: string
    state: string
  }

  export type LocationDemandAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    region?: SortOrder
    city?: SortOrder
    state?: SortOrder
    total_searches?: SortOrder
    successful_bookings?: SortOrder
    revenue_generated?: SortOrder
    peak_hours?: SortOrder
    popular_routes?: SortOrder
    average_fare?: SortOrder
    demand_score?: SortOrder
    updated_at?: SortOrder
  }

  export type LocationDemandAnalyticsAvgOrderByAggregateInput = {
    total_searches?: SortOrder
    successful_bookings?: SortOrder
    revenue_generated?: SortOrder
    average_fare?: SortOrder
    demand_score?: SortOrder
  }

  export type LocationDemandAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    region?: SortOrder
    city?: SortOrder
    state?: SortOrder
    total_searches?: SortOrder
    successful_bookings?: SortOrder
    revenue_generated?: SortOrder
    average_fare?: SortOrder
    demand_score?: SortOrder
    updated_at?: SortOrder
  }

  export type LocationDemandAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    region?: SortOrder
    city?: SortOrder
    state?: SortOrder
    total_searches?: SortOrder
    successful_bookings?: SortOrder
    revenue_generated?: SortOrder
    average_fare?: SortOrder
    demand_score?: SortOrder
    updated_at?: SortOrder
  }

  export type LocationDemandAnalyticsSumOrderByAggregateInput = {
    total_searches?: SortOrder
    successful_bookings?: SortOrder
    revenue_generated?: SortOrder
    average_fare?: SortOrder
    demand_score?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type PricingAnalyticsOrderByRelevanceInput = {
    fields: PricingAnalyticsOrderByRelevanceFieldEnum | PricingAnalyticsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PricingAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    route_hash?: SortOrder
    base_price?: SortOrder
    surge_multiplier?: SortOrder
    peak_hour_rate?: SortOrder
    off_peak_rate?: SortOrder
    competitor_price?: SortOrder
    success_rate?: SortOrder
    last_updated?: SortOrder
  }

  export type PricingAnalyticsAvgOrderByAggregateInput = {
    base_price?: SortOrder
    surge_multiplier?: SortOrder
    peak_hour_rate?: SortOrder
    off_peak_rate?: SortOrder
    competitor_price?: SortOrder
    success_rate?: SortOrder
  }

  export type PricingAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    route_hash?: SortOrder
    base_price?: SortOrder
    surge_multiplier?: SortOrder
    peak_hour_rate?: SortOrder
    off_peak_rate?: SortOrder
    competitor_price?: SortOrder
    success_rate?: SortOrder
    last_updated?: SortOrder
  }

  export type PricingAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    route_hash?: SortOrder
    base_price?: SortOrder
    surge_multiplier?: SortOrder
    peak_hour_rate?: SortOrder
    off_peak_rate?: SortOrder
    competitor_price?: SortOrder
    success_rate?: SortOrder
    last_updated?: SortOrder
  }

  export type PricingAnalyticsSumOrderByAggregateInput = {
    base_price?: SortOrder
    surge_multiplier?: SortOrder
    peak_hour_rate?: SortOrder
    off_peak_rate?: SortOrder
    competitor_price?: SortOrder
    success_rate?: SortOrder
  }

  export type RouteListRelationFilter = {
    every?: RouteWhereInput
    some?: RouteWhereInput
    none?: RouteWhereInput
  }

  export type StopListRelationFilter = {
    every?: StopWhereInput
    some?: StopWhereInput
    none?: StopWhereInput
  }

  export type RouteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LocationOrderByRelevanceInput = {
    fields: LocationOrderByRelevanceFieldEnum | LocationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type LocationCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    district?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    district?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    district?: SortOrder
    state?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LocationScalarRelationFilter = {
    is?: LocationWhereInput
    isNot?: LocationWhereInput
  }

  export type RouteFareListRelationFilter = {
    every?: RouteFareWhereInput
    some?: RouteFareWhereInput
    none?: RouteFareWhereInput
  }

  export type RouteAvailabilityListRelationFilter = {
    every?: RouteAvailabilityWhereInput
    some?: RouteAvailabilityWhereInput
    none?: RouteAvailabilityWhereInput
  }

  export type RouteFareOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RouteAvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RouteOrderByRelevanceInput = {
    fields: RouteOrderByRelevanceFieldEnum | RouteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RouteCountOrderByAggregateInput = {
    id?: SortOrder
    originId?: SortOrder
    destinationId?: SortOrder
    directionType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteMaxOrderByAggregateInput = {
    id?: SortOrder
    originId?: SortOrder
    destinationId?: SortOrder
    directionType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteMinOrderByAggregateInput = {
    id?: SortOrder
    originId?: SortOrder
    destinationId?: SortOrder
    directionType?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteScalarRelationFilter = {
    is?: RouteWhereInput
    isNot?: RouteWhereInput
  }

  export type StopOrderByRelevanceInput = {
    fields: StopOrderByRelevanceFieldEnum | StopOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StopCountOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    distanceKm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StopAvgOrderByAggregateInput = {
    order?: SortOrder
    distanceKm?: SortOrder
  }

  export type StopMaxOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    distanceKm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StopMinOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    locationId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    distanceKm?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StopSumOrderByAggregateInput = {
    order?: SortOrder
    distanceKm?: SortOrder
  }

  export type RouteFareOrderByRelevanceInput = {
    fields: RouteFareOrderByRelevanceFieldEnum | RouteFareOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RouteFareCountOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    vehicleType?: SortOrder
    pricingType?: SortOrder
    baseFare?: SortOrder
    perKmRate?: SortOrder
    perHourRate?: SortOrder
    nightCharge?: SortOrder
    hillCharge?: SortOrder
    waitingCharge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteFareAvgOrderByAggregateInput = {
    baseFare?: SortOrder
    perKmRate?: SortOrder
    perHourRate?: SortOrder
    nightCharge?: SortOrder
    hillCharge?: SortOrder
    waitingCharge?: SortOrder
  }

  export type RouteFareMaxOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    vehicleType?: SortOrder
    pricingType?: SortOrder
    baseFare?: SortOrder
    perKmRate?: SortOrder
    perHourRate?: SortOrder
    nightCharge?: SortOrder
    hillCharge?: SortOrder
    waitingCharge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteFareMinOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    vehicleType?: SortOrder
    pricingType?: SortOrder
    baseFare?: SortOrder
    perKmRate?: SortOrder
    perHourRate?: SortOrder
    nightCharge?: SortOrder
    hillCharge?: SortOrder
    waitingCharge?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteFareSumOrderByAggregateInput = {
    baseFare?: SortOrder
    perKmRate?: SortOrder
    perHourRate?: SortOrder
    nightCharge?: SortOrder
    hillCharge?: SortOrder
    waitingCharge?: SortOrder
  }

  export type RouteAvailabilityOrderByRelevanceInput = {
    fields: RouteAvailabilityOrderByRelevanceFieldEnum | RouteAvailabilityOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type RouteAvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    vehicleType?: SortOrder
    isAvailable?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteAvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    vehicleType?: SortOrder
    isAvailable?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RouteAvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    routeId?: SortOrder
    vehicleType?: SortOrder
    isAvailable?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SearchHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type SearchHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type SearchHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutUserInput | SearchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutUserInput | SearchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutUserInput | SearchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SearchHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput> | SearchHistoryCreateWithoutUserInput[] | SearchHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutUserInput | SearchHistoryCreateOrConnectWithoutUserInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutUserInput | SearchHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SearchHistoryCreateManyUserInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutUserInput | SearchHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutUserInput | SearchHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSearchesInput = {
    create?: XOR<UserCreateWithoutSearchesInput, UserUncheckedCreateWithoutSearchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchesInput
    connect?: UserWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutSearchesNestedInput = {
    create?: XOR<UserCreateWithoutSearchesInput, UserUncheckedCreateWithoutSearchesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSearchesInput
    upsert?: UserUpsertWithoutSearchesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSearchesInput, UserUpdateWithoutSearchesInput>, UserUncheckedUpdateWithoutSearchesInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RouteCreateNestedManyWithoutOriginInput = {
    create?: XOR<RouteCreateWithoutOriginInput, RouteUncheckedCreateWithoutOriginInput> | RouteCreateWithoutOriginInput[] | RouteUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutOriginInput | RouteCreateOrConnectWithoutOriginInput[]
    createMany?: RouteCreateManyOriginInputEnvelope
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
  }

  export type RouteCreateNestedManyWithoutDestinationInput = {
    create?: XOR<RouteCreateWithoutDestinationInput, RouteUncheckedCreateWithoutDestinationInput> | RouteCreateWithoutDestinationInput[] | RouteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutDestinationInput | RouteCreateOrConnectWithoutDestinationInput[]
    createMany?: RouteCreateManyDestinationInputEnvelope
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
  }

  export type StopCreateNestedManyWithoutLocationInput = {
    create?: XOR<StopCreateWithoutLocationInput, StopUncheckedCreateWithoutLocationInput> | StopCreateWithoutLocationInput[] | StopUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StopCreateOrConnectWithoutLocationInput | StopCreateOrConnectWithoutLocationInput[]
    createMany?: StopCreateManyLocationInputEnvelope
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
  }

  export type RouteUncheckedCreateNestedManyWithoutOriginInput = {
    create?: XOR<RouteCreateWithoutOriginInput, RouteUncheckedCreateWithoutOriginInput> | RouteCreateWithoutOriginInput[] | RouteUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutOriginInput | RouteCreateOrConnectWithoutOriginInput[]
    createMany?: RouteCreateManyOriginInputEnvelope
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
  }

  export type RouteUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<RouteCreateWithoutDestinationInput, RouteUncheckedCreateWithoutDestinationInput> | RouteCreateWithoutDestinationInput[] | RouteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutDestinationInput | RouteCreateOrConnectWithoutDestinationInput[]
    createMany?: RouteCreateManyDestinationInputEnvelope
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
  }

  export type StopUncheckedCreateNestedManyWithoutLocationInput = {
    create?: XOR<StopCreateWithoutLocationInput, StopUncheckedCreateWithoutLocationInput> | StopCreateWithoutLocationInput[] | StopUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StopCreateOrConnectWithoutLocationInput | StopCreateOrConnectWithoutLocationInput[]
    createMany?: StopCreateManyLocationInputEnvelope
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
  }

  export type RouteUpdateManyWithoutOriginNestedInput = {
    create?: XOR<RouteCreateWithoutOriginInput, RouteUncheckedCreateWithoutOriginInput> | RouteCreateWithoutOriginInput[] | RouteUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutOriginInput | RouteCreateOrConnectWithoutOriginInput[]
    upsert?: RouteUpsertWithWhereUniqueWithoutOriginInput | RouteUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: RouteCreateManyOriginInputEnvelope
    set?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    disconnect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    delete?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    update?: RouteUpdateWithWhereUniqueWithoutOriginInput | RouteUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: RouteUpdateManyWithWhereWithoutOriginInput | RouteUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: RouteScalarWhereInput | RouteScalarWhereInput[]
  }

  export type RouteUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<RouteCreateWithoutDestinationInput, RouteUncheckedCreateWithoutDestinationInput> | RouteCreateWithoutDestinationInput[] | RouteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutDestinationInput | RouteCreateOrConnectWithoutDestinationInput[]
    upsert?: RouteUpsertWithWhereUniqueWithoutDestinationInput | RouteUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: RouteCreateManyDestinationInputEnvelope
    set?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    disconnect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    delete?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    update?: RouteUpdateWithWhereUniqueWithoutDestinationInput | RouteUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: RouteUpdateManyWithWhereWithoutDestinationInput | RouteUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: RouteScalarWhereInput | RouteScalarWhereInput[]
  }

  export type StopUpdateManyWithoutLocationNestedInput = {
    create?: XOR<StopCreateWithoutLocationInput, StopUncheckedCreateWithoutLocationInput> | StopCreateWithoutLocationInput[] | StopUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StopCreateOrConnectWithoutLocationInput | StopCreateOrConnectWithoutLocationInput[]
    upsert?: StopUpsertWithWhereUniqueWithoutLocationInput | StopUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: StopCreateManyLocationInputEnvelope
    set?: StopWhereUniqueInput | StopWhereUniqueInput[]
    disconnect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    delete?: StopWhereUniqueInput | StopWhereUniqueInput[]
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    update?: StopUpdateWithWhereUniqueWithoutLocationInput | StopUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: StopUpdateManyWithWhereWithoutLocationInput | StopUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: StopScalarWhereInput | StopScalarWhereInput[]
  }

  export type RouteUncheckedUpdateManyWithoutOriginNestedInput = {
    create?: XOR<RouteCreateWithoutOriginInput, RouteUncheckedCreateWithoutOriginInput> | RouteCreateWithoutOriginInput[] | RouteUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutOriginInput | RouteCreateOrConnectWithoutOriginInput[]
    upsert?: RouteUpsertWithWhereUniqueWithoutOriginInput | RouteUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: RouteCreateManyOriginInputEnvelope
    set?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    disconnect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    delete?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    update?: RouteUpdateWithWhereUniqueWithoutOriginInput | RouteUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: RouteUpdateManyWithWhereWithoutOriginInput | RouteUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: RouteScalarWhereInput | RouteScalarWhereInput[]
  }

  export type RouteUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<RouteCreateWithoutDestinationInput, RouteUncheckedCreateWithoutDestinationInput> | RouteCreateWithoutDestinationInput[] | RouteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: RouteCreateOrConnectWithoutDestinationInput | RouteCreateOrConnectWithoutDestinationInput[]
    upsert?: RouteUpsertWithWhereUniqueWithoutDestinationInput | RouteUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: RouteCreateManyDestinationInputEnvelope
    set?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    disconnect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    delete?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    connect?: RouteWhereUniqueInput | RouteWhereUniqueInput[]
    update?: RouteUpdateWithWhereUniqueWithoutDestinationInput | RouteUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: RouteUpdateManyWithWhereWithoutDestinationInput | RouteUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: RouteScalarWhereInput | RouteScalarWhereInput[]
  }

  export type StopUncheckedUpdateManyWithoutLocationNestedInput = {
    create?: XOR<StopCreateWithoutLocationInput, StopUncheckedCreateWithoutLocationInput> | StopCreateWithoutLocationInput[] | StopUncheckedCreateWithoutLocationInput[]
    connectOrCreate?: StopCreateOrConnectWithoutLocationInput | StopCreateOrConnectWithoutLocationInput[]
    upsert?: StopUpsertWithWhereUniqueWithoutLocationInput | StopUpsertWithWhereUniqueWithoutLocationInput[]
    createMany?: StopCreateManyLocationInputEnvelope
    set?: StopWhereUniqueInput | StopWhereUniqueInput[]
    disconnect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    delete?: StopWhereUniqueInput | StopWhereUniqueInput[]
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    update?: StopUpdateWithWhereUniqueWithoutLocationInput | StopUpdateWithWhereUniqueWithoutLocationInput[]
    updateMany?: StopUpdateManyWithWhereWithoutLocationInput | StopUpdateManyWithWhereWithoutLocationInput[]
    deleteMany?: StopScalarWhereInput | StopScalarWhereInput[]
  }

  export type LocationCreateNestedOneWithoutRoutesFromInput = {
    create?: XOR<LocationCreateWithoutRoutesFromInput, LocationUncheckedCreateWithoutRoutesFromInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRoutesFromInput
    connect?: LocationWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutRoutesToInput = {
    create?: XOR<LocationCreateWithoutRoutesToInput, LocationUncheckedCreateWithoutRoutesToInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRoutesToInput
    connect?: LocationWhereUniqueInput
  }

  export type StopCreateNestedManyWithoutRouteInput = {
    create?: XOR<StopCreateWithoutRouteInput, StopUncheckedCreateWithoutRouteInput> | StopCreateWithoutRouteInput[] | StopUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: StopCreateOrConnectWithoutRouteInput | StopCreateOrConnectWithoutRouteInput[]
    createMany?: StopCreateManyRouteInputEnvelope
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
  }

  export type RouteFareCreateNestedManyWithoutRouteInput = {
    create?: XOR<RouteFareCreateWithoutRouteInput, RouteFareUncheckedCreateWithoutRouteInput> | RouteFareCreateWithoutRouteInput[] | RouteFareUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteFareCreateOrConnectWithoutRouteInput | RouteFareCreateOrConnectWithoutRouteInput[]
    createMany?: RouteFareCreateManyRouteInputEnvelope
    connect?: RouteFareWhereUniqueInput | RouteFareWhereUniqueInput[]
  }

  export type RouteAvailabilityCreateNestedManyWithoutRouteInput = {
    create?: XOR<RouteAvailabilityCreateWithoutRouteInput, RouteAvailabilityUncheckedCreateWithoutRouteInput> | RouteAvailabilityCreateWithoutRouteInput[] | RouteAvailabilityUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteAvailabilityCreateOrConnectWithoutRouteInput | RouteAvailabilityCreateOrConnectWithoutRouteInput[]
    createMany?: RouteAvailabilityCreateManyRouteInputEnvelope
    connect?: RouteAvailabilityWhereUniqueInput | RouteAvailabilityWhereUniqueInput[]
  }

  export type StopUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<StopCreateWithoutRouteInput, StopUncheckedCreateWithoutRouteInput> | StopCreateWithoutRouteInput[] | StopUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: StopCreateOrConnectWithoutRouteInput | StopCreateOrConnectWithoutRouteInput[]
    createMany?: StopCreateManyRouteInputEnvelope
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
  }

  export type RouteFareUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<RouteFareCreateWithoutRouteInput, RouteFareUncheckedCreateWithoutRouteInput> | RouteFareCreateWithoutRouteInput[] | RouteFareUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteFareCreateOrConnectWithoutRouteInput | RouteFareCreateOrConnectWithoutRouteInput[]
    createMany?: RouteFareCreateManyRouteInputEnvelope
    connect?: RouteFareWhereUniqueInput | RouteFareWhereUniqueInput[]
  }

  export type RouteAvailabilityUncheckedCreateNestedManyWithoutRouteInput = {
    create?: XOR<RouteAvailabilityCreateWithoutRouteInput, RouteAvailabilityUncheckedCreateWithoutRouteInput> | RouteAvailabilityCreateWithoutRouteInput[] | RouteAvailabilityUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteAvailabilityCreateOrConnectWithoutRouteInput | RouteAvailabilityCreateOrConnectWithoutRouteInput[]
    createMany?: RouteAvailabilityCreateManyRouteInputEnvelope
    connect?: RouteAvailabilityWhereUniqueInput | RouteAvailabilityWhereUniqueInput[]
  }

  export type LocationUpdateOneRequiredWithoutRoutesFromNestedInput = {
    create?: XOR<LocationCreateWithoutRoutesFromInput, LocationUncheckedCreateWithoutRoutesFromInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRoutesFromInput
    upsert?: LocationUpsertWithoutRoutesFromInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutRoutesFromInput, LocationUpdateWithoutRoutesFromInput>, LocationUncheckedUpdateWithoutRoutesFromInput>
  }

  export type LocationUpdateOneRequiredWithoutRoutesToNestedInput = {
    create?: XOR<LocationCreateWithoutRoutesToInput, LocationUncheckedCreateWithoutRoutesToInput>
    connectOrCreate?: LocationCreateOrConnectWithoutRoutesToInput
    upsert?: LocationUpsertWithoutRoutesToInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutRoutesToInput, LocationUpdateWithoutRoutesToInput>, LocationUncheckedUpdateWithoutRoutesToInput>
  }

  export type StopUpdateManyWithoutRouteNestedInput = {
    create?: XOR<StopCreateWithoutRouteInput, StopUncheckedCreateWithoutRouteInput> | StopCreateWithoutRouteInput[] | StopUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: StopCreateOrConnectWithoutRouteInput | StopCreateOrConnectWithoutRouteInput[]
    upsert?: StopUpsertWithWhereUniqueWithoutRouteInput | StopUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: StopCreateManyRouteInputEnvelope
    set?: StopWhereUniqueInput | StopWhereUniqueInput[]
    disconnect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    delete?: StopWhereUniqueInput | StopWhereUniqueInput[]
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    update?: StopUpdateWithWhereUniqueWithoutRouteInput | StopUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: StopUpdateManyWithWhereWithoutRouteInput | StopUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: StopScalarWhereInput | StopScalarWhereInput[]
  }

  export type RouteFareUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RouteFareCreateWithoutRouteInput, RouteFareUncheckedCreateWithoutRouteInput> | RouteFareCreateWithoutRouteInput[] | RouteFareUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteFareCreateOrConnectWithoutRouteInput | RouteFareCreateOrConnectWithoutRouteInput[]
    upsert?: RouteFareUpsertWithWhereUniqueWithoutRouteInput | RouteFareUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RouteFareCreateManyRouteInputEnvelope
    set?: RouteFareWhereUniqueInput | RouteFareWhereUniqueInput[]
    disconnect?: RouteFareWhereUniqueInput | RouteFareWhereUniqueInput[]
    delete?: RouteFareWhereUniqueInput | RouteFareWhereUniqueInput[]
    connect?: RouteFareWhereUniqueInput | RouteFareWhereUniqueInput[]
    update?: RouteFareUpdateWithWhereUniqueWithoutRouteInput | RouteFareUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RouteFareUpdateManyWithWhereWithoutRouteInput | RouteFareUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RouteFareScalarWhereInput | RouteFareScalarWhereInput[]
  }

  export type RouteAvailabilityUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RouteAvailabilityCreateWithoutRouteInput, RouteAvailabilityUncheckedCreateWithoutRouteInput> | RouteAvailabilityCreateWithoutRouteInput[] | RouteAvailabilityUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteAvailabilityCreateOrConnectWithoutRouteInput | RouteAvailabilityCreateOrConnectWithoutRouteInput[]
    upsert?: RouteAvailabilityUpsertWithWhereUniqueWithoutRouteInput | RouteAvailabilityUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RouteAvailabilityCreateManyRouteInputEnvelope
    set?: RouteAvailabilityWhereUniqueInput | RouteAvailabilityWhereUniqueInput[]
    disconnect?: RouteAvailabilityWhereUniqueInput | RouteAvailabilityWhereUniqueInput[]
    delete?: RouteAvailabilityWhereUniqueInput | RouteAvailabilityWhereUniqueInput[]
    connect?: RouteAvailabilityWhereUniqueInput | RouteAvailabilityWhereUniqueInput[]
    update?: RouteAvailabilityUpdateWithWhereUniqueWithoutRouteInput | RouteAvailabilityUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RouteAvailabilityUpdateManyWithWhereWithoutRouteInput | RouteAvailabilityUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RouteAvailabilityScalarWhereInput | RouteAvailabilityScalarWhereInput[]
  }

  export type StopUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<StopCreateWithoutRouteInput, StopUncheckedCreateWithoutRouteInput> | StopCreateWithoutRouteInput[] | StopUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: StopCreateOrConnectWithoutRouteInput | StopCreateOrConnectWithoutRouteInput[]
    upsert?: StopUpsertWithWhereUniqueWithoutRouteInput | StopUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: StopCreateManyRouteInputEnvelope
    set?: StopWhereUniqueInput | StopWhereUniqueInput[]
    disconnect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    delete?: StopWhereUniqueInput | StopWhereUniqueInput[]
    connect?: StopWhereUniqueInput | StopWhereUniqueInput[]
    update?: StopUpdateWithWhereUniqueWithoutRouteInput | StopUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: StopUpdateManyWithWhereWithoutRouteInput | StopUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: StopScalarWhereInput | StopScalarWhereInput[]
  }

  export type RouteFareUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RouteFareCreateWithoutRouteInput, RouteFareUncheckedCreateWithoutRouteInput> | RouteFareCreateWithoutRouteInput[] | RouteFareUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteFareCreateOrConnectWithoutRouteInput | RouteFareCreateOrConnectWithoutRouteInput[]
    upsert?: RouteFareUpsertWithWhereUniqueWithoutRouteInput | RouteFareUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RouteFareCreateManyRouteInputEnvelope
    set?: RouteFareWhereUniqueInput | RouteFareWhereUniqueInput[]
    disconnect?: RouteFareWhereUniqueInput | RouteFareWhereUniqueInput[]
    delete?: RouteFareWhereUniqueInput | RouteFareWhereUniqueInput[]
    connect?: RouteFareWhereUniqueInput | RouteFareWhereUniqueInput[]
    update?: RouteFareUpdateWithWhereUniqueWithoutRouteInput | RouteFareUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RouteFareUpdateManyWithWhereWithoutRouteInput | RouteFareUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RouteFareScalarWhereInput | RouteFareScalarWhereInput[]
  }

  export type RouteAvailabilityUncheckedUpdateManyWithoutRouteNestedInput = {
    create?: XOR<RouteAvailabilityCreateWithoutRouteInput, RouteAvailabilityUncheckedCreateWithoutRouteInput> | RouteAvailabilityCreateWithoutRouteInput[] | RouteAvailabilityUncheckedCreateWithoutRouteInput[]
    connectOrCreate?: RouteAvailabilityCreateOrConnectWithoutRouteInput | RouteAvailabilityCreateOrConnectWithoutRouteInput[]
    upsert?: RouteAvailabilityUpsertWithWhereUniqueWithoutRouteInput | RouteAvailabilityUpsertWithWhereUniqueWithoutRouteInput[]
    createMany?: RouteAvailabilityCreateManyRouteInputEnvelope
    set?: RouteAvailabilityWhereUniqueInput | RouteAvailabilityWhereUniqueInput[]
    disconnect?: RouteAvailabilityWhereUniqueInput | RouteAvailabilityWhereUniqueInput[]
    delete?: RouteAvailabilityWhereUniqueInput | RouteAvailabilityWhereUniqueInput[]
    connect?: RouteAvailabilityWhereUniqueInput | RouteAvailabilityWhereUniqueInput[]
    update?: RouteAvailabilityUpdateWithWhereUniqueWithoutRouteInput | RouteAvailabilityUpdateWithWhereUniqueWithoutRouteInput[]
    updateMany?: RouteAvailabilityUpdateManyWithWhereWithoutRouteInput | RouteAvailabilityUpdateManyWithWhereWithoutRouteInput[]
    deleteMany?: RouteAvailabilityScalarWhereInput | RouteAvailabilityScalarWhereInput[]
  }

  export type RouteCreateNestedOneWithoutStopsInput = {
    create?: XOR<RouteCreateWithoutStopsInput, RouteUncheckedCreateWithoutStopsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutStopsInput
    connect?: RouteWhereUniqueInput
  }

  export type LocationCreateNestedOneWithoutStopsInput = {
    create?: XOR<LocationCreateWithoutStopsInput, LocationUncheckedCreateWithoutStopsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStopsInput
    connect?: LocationWhereUniqueInput
  }

  export type RouteUpdateOneRequiredWithoutStopsNestedInput = {
    create?: XOR<RouteCreateWithoutStopsInput, RouteUncheckedCreateWithoutStopsInput>
    connectOrCreate?: RouteCreateOrConnectWithoutStopsInput
    upsert?: RouteUpsertWithoutStopsInput
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutStopsInput, RouteUpdateWithoutStopsInput>, RouteUncheckedUpdateWithoutStopsInput>
  }

  export type LocationUpdateOneRequiredWithoutStopsNestedInput = {
    create?: XOR<LocationCreateWithoutStopsInput, LocationUncheckedCreateWithoutStopsInput>
    connectOrCreate?: LocationCreateOrConnectWithoutStopsInput
    upsert?: LocationUpsertWithoutStopsInput
    connect?: LocationWhereUniqueInput
    update?: XOR<XOR<LocationUpdateToOneWithWhereWithoutStopsInput, LocationUpdateWithoutStopsInput>, LocationUncheckedUpdateWithoutStopsInput>
  }

  export type RouteCreateNestedOneWithoutFaresInput = {
    create?: XOR<RouteCreateWithoutFaresInput, RouteUncheckedCreateWithoutFaresInput>
    connectOrCreate?: RouteCreateOrConnectWithoutFaresInput
    connect?: RouteWhereUniqueInput
  }

  export type RouteUpdateOneRequiredWithoutFaresNestedInput = {
    create?: XOR<RouteCreateWithoutFaresInput, RouteUncheckedCreateWithoutFaresInput>
    connectOrCreate?: RouteCreateOrConnectWithoutFaresInput
    upsert?: RouteUpsertWithoutFaresInput
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutFaresInput, RouteUpdateWithoutFaresInput>, RouteUncheckedUpdateWithoutFaresInput>
  }

  export type RouteCreateNestedOneWithoutAvailabilityInput = {
    create?: XOR<RouteCreateWithoutAvailabilityInput, RouteUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: RouteCreateOrConnectWithoutAvailabilityInput
    connect?: RouteWhereUniqueInput
  }

  export type RouteUpdateOneRequiredWithoutAvailabilityNestedInput = {
    create?: XOR<RouteCreateWithoutAvailabilityInput, RouteUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: RouteCreateOrConnectWithoutAvailabilityInput
    upsert?: RouteUpsertWithoutAvailabilityInput
    connect?: RouteWhereUniqueInput
    update?: XOR<XOR<RouteUpdateToOneWithWhereWithoutAvailabilityInput, RouteUpdateWithoutAvailabilityInput>, RouteUncheckedUpdateWithoutAvailabilityInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SearchHistoryCreateWithoutUserInput = {
    id?: string
    search_query: string
    latitude?: number | null
    longitude?: number | null
    search_count?: number
    first_searched?: Date | string
    last_searched?: Date | string
    user_type?: string
    device?: string | null
    is_successful?: boolean
    converted_to_booking?: boolean
    booking_id?: string | null
    session_id?: string | null
    source_page?: string | null
    search_category?: string | null
    estimated_distance?: number | null
    estimated_duration?: number | null
    peak_hour_search?: boolean
    region?: string | null
    city?: string | null
    state?: string | null
    search_completion_rate?: number | null
    user_agent?: string | null
    ip_address?: string | null
    referral_source?: string | null
    time_to_result?: number | null
    competitor_price_check?: boolean
    potential_revenue?: number | null
    seasonal_factor?: number | null
    market_demand_score?: number | null
  }

  export type SearchHistoryUncheckedCreateWithoutUserInput = {
    id?: string
    search_query: string
    latitude?: number | null
    longitude?: number | null
    search_count?: number
    first_searched?: Date | string
    last_searched?: Date | string
    user_type?: string
    device?: string | null
    is_successful?: boolean
    converted_to_booking?: boolean
    booking_id?: string | null
    session_id?: string | null
    source_page?: string | null
    search_category?: string | null
    estimated_distance?: number | null
    estimated_duration?: number | null
    peak_hour_search?: boolean
    region?: string | null
    city?: string | null
    state?: string | null
    search_completion_rate?: number | null
    user_agent?: string | null
    ip_address?: string | null
    referral_source?: string | null
    time_to_result?: number | null
    competitor_price_check?: boolean
    potential_revenue?: number | null
    seasonal_factor?: number | null
    market_demand_score?: number | null
  }

  export type SearchHistoryCreateOrConnectWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    create: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput>
  }

  export type SearchHistoryCreateManyUserInputEnvelope = {
    data: SearchHistoryCreateManyUserInput | SearchHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SearchHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    update: XOR<SearchHistoryUpdateWithoutUserInput, SearchHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<SearchHistoryCreateWithoutUserInput, SearchHistoryUncheckedCreateWithoutUserInput>
  }

  export type SearchHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: SearchHistoryWhereUniqueInput
    data: XOR<SearchHistoryUpdateWithoutUserInput, SearchHistoryUncheckedUpdateWithoutUserInput>
  }

  export type SearchHistoryUpdateManyWithWhereWithoutUserInput = {
    where: SearchHistoryScalarWhereInput
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type SearchHistoryScalarWhereInput = {
    AND?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    OR?: SearchHistoryScalarWhereInput[]
    NOT?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    id?: StringFilter<"SearchHistory"> | string
    search_query?: StringFilter<"SearchHistory"> | string
    latitude?: FloatNullableFilter<"SearchHistory"> | number | null
    longitude?: FloatNullableFilter<"SearchHistory"> | number | null
    search_count?: IntFilter<"SearchHistory"> | number
    first_searched?: DateTimeFilter<"SearchHistory"> | Date | string
    last_searched?: DateTimeFilter<"SearchHistory"> | Date | string
    user_type?: StringFilter<"SearchHistory"> | string
    device?: StringNullableFilter<"SearchHistory"> | string | null
    is_successful?: BoolFilter<"SearchHistory"> | boolean
    converted_to_booking?: BoolFilter<"SearchHistory"> | boolean
    booking_id?: StringNullableFilter<"SearchHistory"> | string | null
    user_id?: IntNullableFilter<"SearchHistory"> | number | null
    session_id?: StringNullableFilter<"SearchHistory"> | string | null
    source_page?: StringNullableFilter<"SearchHistory"> | string | null
    search_category?: StringNullableFilter<"SearchHistory"> | string | null
    estimated_distance?: FloatNullableFilter<"SearchHistory"> | number | null
    estimated_duration?: IntNullableFilter<"SearchHistory"> | number | null
    peak_hour_search?: BoolFilter<"SearchHistory"> | boolean
    region?: StringNullableFilter<"SearchHistory"> | string | null
    city?: StringNullableFilter<"SearchHistory"> | string | null
    state?: StringNullableFilter<"SearchHistory"> | string | null
    search_completion_rate?: FloatNullableFilter<"SearchHistory"> | number | null
    user_agent?: StringNullableFilter<"SearchHistory"> | string | null
    ip_address?: StringNullableFilter<"SearchHistory"> | string | null
    referral_source?: StringNullableFilter<"SearchHistory"> | string | null
    time_to_result?: IntNullableFilter<"SearchHistory"> | number | null
    competitor_price_check?: BoolFilter<"SearchHistory"> | boolean
    potential_revenue?: FloatNullableFilter<"SearchHistory"> | number | null
    seasonal_factor?: FloatNullableFilter<"SearchHistory"> | number | null
    market_demand_score?: IntNullableFilter<"SearchHistory"> | number | null
  }

  export type UserCreateWithoutSearchesInput = {
    fullName: string
    email: string
    phone: string
    employeeId: string
    designation: string
    department: string
    manager: string
    approver: string
    password?: string | null
    pin?: string | null
    authCode?: string | null
    status?: string
    needsPasswordChange?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutSearchesInput = {
    id?: number
    fullName: string
    email: string
    phone: string
    employeeId: string
    designation: string
    department: string
    manager: string
    approver: string
    password?: string | null
    pin?: string | null
    authCode?: string | null
    status?: string
    needsPasswordChange?: boolean
    role?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutSearchesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSearchesInput, UserUncheckedCreateWithoutSearchesInput>
  }

  export type UserUpsertWithoutSearchesInput = {
    update: XOR<UserUpdateWithoutSearchesInput, UserUncheckedUpdateWithoutSearchesInput>
    create: XOR<UserCreateWithoutSearchesInput, UserUncheckedCreateWithoutSearchesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSearchesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSearchesInput, UserUncheckedUpdateWithoutSearchesInput>
  }

  export type UserUpdateWithoutSearchesInput = {
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    approver?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    needsPasswordChange?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutSearchesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    designation?: StringFieldUpdateOperationsInput | string
    department?: StringFieldUpdateOperationsInput | string
    manager?: StringFieldUpdateOperationsInput | string
    approver?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    authCode?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    needsPasswordChange?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteCreateWithoutOriginInput = {
    id?: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    destination: LocationCreateNestedOneWithoutRoutesToInput
    stops?: StopCreateNestedManyWithoutRouteInput
    fares?: RouteFareCreateNestedManyWithoutRouteInput
    availability?: RouteAvailabilityCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutOriginInput = {
    id?: string
    destinationId: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stops?: StopUncheckedCreateNestedManyWithoutRouteInput
    fares?: RouteFareUncheckedCreateNestedManyWithoutRouteInput
    availability?: RouteAvailabilityUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutOriginInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutOriginInput, RouteUncheckedCreateWithoutOriginInput>
  }

  export type RouteCreateManyOriginInputEnvelope = {
    data: RouteCreateManyOriginInput | RouteCreateManyOriginInput[]
    skipDuplicates?: boolean
  }

  export type RouteCreateWithoutDestinationInput = {
    id?: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    origin: LocationCreateNestedOneWithoutRoutesFromInput
    stops?: StopCreateNestedManyWithoutRouteInput
    fares?: RouteFareCreateNestedManyWithoutRouteInput
    availability?: RouteAvailabilityCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutDestinationInput = {
    id?: string
    originId: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stops?: StopUncheckedCreateNestedManyWithoutRouteInput
    fares?: RouteFareUncheckedCreateNestedManyWithoutRouteInput
    availability?: RouteAvailabilityUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutDestinationInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutDestinationInput, RouteUncheckedCreateWithoutDestinationInput>
  }

  export type RouteCreateManyDestinationInputEnvelope = {
    data: RouteCreateManyDestinationInput | RouteCreateManyDestinationInput[]
    skipDuplicates?: boolean
  }

  export type StopCreateWithoutLocationInput = {
    id?: string
    name: string
    order: number
    distanceKm?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    route: RouteCreateNestedOneWithoutStopsInput
  }

  export type StopUncheckedCreateWithoutLocationInput = {
    id?: string
    routeId: string
    name: string
    order: number
    distanceKm?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StopCreateOrConnectWithoutLocationInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutLocationInput, StopUncheckedCreateWithoutLocationInput>
  }

  export type StopCreateManyLocationInputEnvelope = {
    data: StopCreateManyLocationInput | StopCreateManyLocationInput[]
    skipDuplicates?: boolean
  }

  export type RouteUpsertWithWhereUniqueWithoutOriginInput = {
    where: RouteWhereUniqueInput
    update: XOR<RouteUpdateWithoutOriginInput, RouteUncheckedUpdateWithoutOriginInput>
    create: XOR<RouteCreateWithoutOriginInput, RouteUncheckedCreateWithoutOriginInput>
  }

  export type RouteUpdateWithWhereUniqueWithoutOriginInput = {
    where: RouteWhereUniqueInput
    data: XOR<RouteUpdateWithoutOriginInput, RouteUncheckedUpdateWithoutOriginInput>
  }

  export type RouteUpdateManyWithWhereWithoutOriginInput = {
    where: RouteScalarWhereInput
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyWithoutOriginInput>
  }

  export type RouteScalarWhereInput = {
    AND?: RouteScalarWhereInput | RouteScalarWhereInput[]
    OR?: RouteScalarWhereInput[]
    NOT?: RouteScalarWhereInput | RouteScalarWhereInput[]
    id?: StringFilter<"Route"> | string
    originId?: StringFilter<"Route"> | string
    destinationId?: StringFilter<"Route"> | string
    directionType?: StringFilter<"Route"> | string
    isActive?: BoolFilter<"Route"> | boolean
    createdAt?: DateTimeFilter<"Route"> | Date | string
    updatedAt?: DateTimeFilter<"Route"> | Date | string
  }

  export type RouteUpsertWithWhereUniqueWithoutDestinationInput = {
    where: RouteWhereUniqueInput
    update: XOR<RouteUpdateWithoutDestinationInput, RouteUncheckedUpdateWithoutDestinationInput>
    create: XOR<RouteCreateWithoutDestinationInput, RouteUncheckedCreateWithoutDestinationInput>
  }

  export type RouteUpdateWithWhereUniqueWithoutDestinationInput = {
    where: RouteWhereUniqueInput
    data: XOR<RouteUpdateWithoutDestinationInput, RouteUncheckedUpdateWithoutDestinationInput>
  }

  export type RouteUpdateManyWithWhereWithoutDestinationInput = {
    where: RouteScalarWhereInput
    data: XOR<RouteUpdateManyMutationInput, RouteUncheckedUpdateManyWithoutDestinationInput>
  }

  export type StopUpsertWithWhereUniqueWithoutLocationInput = {
    where: StopWhereUniqueInput
    update: XOR<StopUpdateWithoutLocationInput, StopUncheckedUpdateWithoutLocationInput>
    create: XOR<StopCreateWithoutLocationInput, StopUncheckedCreateWithoutLocationInput>
  }

  export type StopUpdateWithWhereUniqueWithoutLocationInput = {
    where: StopWhereUniqueInput
    data: XOR<StopUpdateWithoutLocationInput, StopUncheckedUpdateWithoutLocationInput>
  }

  export type StopUpdateManyWithWhereWithoutLocationInput = {
    where: StopScalarWhereInput
    data: XOR<StopUpdateManyMutationInput, StopUncheckedUpdateManyWithoutLocationInput>
  }

  export type StopScalarWhereInput = {
    AND?: StopScalarWhereInput | StopScalarWhereInput[]
    OR?: StopScalarWhereInput[]
    NOT?: StopScalarWhereInput | StopScalarWhereInput[]
    id?: StringFilter<"Stop"> | string
    routeId?: StringFilter<"Stop"> | string
    locationId?: StringFilter<"Stop"> | string
    name?: StringFilter<"Stop"> | string
    order?: IntFilter<"Stop"> | number
    distanceKm?: FloatNullableFilter<"Stop"> | number | null
    createdAt?: DateTimeFilter<"Stop"> | Date | string
    updatedAt?: DateTimeFilter<"Stop"> | Date | string
  }

  export type LocationCreateWithoutRoutesFromInput = {
    id?: string
    name: string
    district: string
    state?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    routesTo?: RouteCreateNestedManyWithoutDestinationInput
    stops?: StopCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutRoutesFromInput = {
    id?: string
    name: string
    district: string
    state?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    routesTo?: RouteUncheckedCreateNestedManyWithoutDestinationInput
    stops?: StopUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutRoutesFromInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutRoutesFromInput, LocationUncheckedCreateWithoutRoutesFromInput>
  }

  export type LocationCreateWithoutRoutesToInput = {
    id?: string
    name: string
    district: string
    state?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    routesFrom?: RouteCreateNestedManyWithoutOriginInput
    stops?: StopCreateNestedManyWithoutLocationInput
  }

  export type LocationUncheckedCreateWithoutRoutesToInput = {
    id?: string
    name: string
    district: string
    state?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    routesFrom?: RouteUncheckedCreateNestedManyWithoutOriginInput
    stops?: StopUncheckedCreateNestedManyWithoutLocationInput
  }

  export type LocationCreateOrConnectWithoutRoutesToInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutRoutesToInput, LocationUncheckedCreateWithoutRoutesToInput>
  }

  export type StopCreateWithoutRouteInput = {
    id?: string
    name: string
    order: number
    distanceKm?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    location: LocationCreateNestedOneWithoutStopsInput
  }

  export type StopUncheckedCreateWithoutRouteInput = {
    id?: string
    locationId: string
    name: string
    order: number
    distanceKm?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StopCreateOrConnectWithoutRouteInput = {
    where: StopWhereUniqueInput
    create: XOR<StopCreateWithoutRouteInput, StopUncheckedCreateWithoutRouteInput>
  }

  export type StopCreateManyRouteInputEnvelope = {
    data: StopCreateManyRouteInput | StopCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type RouteFareCreateWithoutRouteInput = {
    id?: string
    vehicleType: string
    pricingType: string
    baseFare: number
    perKmRate?: number | null
    perHourRate?: number | null
    nightCharge?: number | null
    hillCharge?: number | null
    waitingCharge?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteFareUncheckedCreateWithoutRouteInput = {
    id?: string
    vehicleType: string
    pricingType: string
    baseFare: number
    perKmRate?: number | null
    perHourRate?: number | null
    nightCharge?: number | null
    hillCharge?: number | null
    waitingCharge?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteFareCreateOrConnectWithoutRouteInput = {
    where: RouteFareWhereUniqueInput
    create: XOR<RouteFareCreateWithoutRouteInput, RouteFareUncheckedCreateWithoutRouteInput>
  }

  export type RouteFareCreateManyRouteInputEnvelope = {
    data: RouteFareCreateManyRouteInput | RouteFareCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type RouteAvailabilityCreateWithoutRouteInput = {
    id?: string
    vehicleType: string
    isAvailable?: boolean
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteAvailabilityUncheckedCreateWithoutRouteInput = {
    id?: string
    vehicleType: string
    isAvailable?: boolean
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteAvailabilityCreateOrConnectWithoutRouteInput = {
    where: RouteAvailabilityWhereUniqueInput
    create: XOR<RouteAvailabilityCreateWithoutRouteInput, RouteAvailabilityUncheckedCreateWithoutRouteInput>
  }

  export type RouteAvailabilityCreateManyRouteInputEnvelope = {
    data: RouteAvailabilityCreateManyRouteInput | RouteAvailabilityCreateManyRouteInput[]
    skipDuplicates?: boolean
  }

  export type LocationUpsertWithoutRoutesFromInput = {
    update: XOR<LocationUpdateWithoutRoutesFromInput, LocationUncheckedUpdateWithoutRoutesFromInput>
    create: XOR<LocationCreateWithoutRoutesFromInput, LocationUncheckedCreateWithoutRoutesFromInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutRoutesFromInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutRoutesFromInput, LocationUncheckedUpdateWithoutRoutesFromInput>
  }

  export type LocationUpdateWithoutRoutesFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routesTo?: RouteUpdateManyWithoutDestinationNestedInput
    stops?: StopUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutRoutesFromInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routesTo?: RouteUncheckedUpdateManyWithoutDestinationNestedInput
    stops?: StopUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type LocationUpsertWithoutRoutesToInput = {
    update: XOR<LocationUpdateWithoutRoutesToInput, LocationUncheckedUpdateWithoutRoutesToInput>
    create: XOR<LocationCreateWithoutRoutesToInput, LocationUncheckedCreateWithoutRoutesToInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutRoutesToInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutRoutesToInput, LocationUncheckedUpdateWithoutRoutesToInput>
  }

  export type LocationUpdateWithoutRoutesToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routesFrom?: RouteUpdateManyWithoutOriginNestedInput
    stops?: StopUpdateManyWithoutLocationNestedInput
  }

  export type LocationUncheckedUpdateWithoutRoutesToInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routesFrom?: RouteUncheckedUpdateManyWithoutOriginNestedInput
    stops?: StopUncheckedUpdateManyWithoutLocationNestedInput
  }

  export type StopUpsertWithWhereUniqueWithoutRouteInput = {
    where: StopWhereUniqueInput
    update: XOR<StopUpdateWithoutRouteInput, StopUncheckedUpdateWithoutRouteInput>
    create: XOR<StopCreateWithoutRouteInput, StopUncheckedCreateWithoutRouteInput>
  }

  export type StopUpdateWithWhereUniqueWithoutRouteInput = {
    where: StopWhereUniqueInput
    data: XOR<StopUpdateWithoutRouteInput, StopUncheckedUpdateWithoutRouteInput>
  }

  export type StopUpdateManyWithWhereWithoutRouteInput = {
    where: StopScalarWhereInput
    data: XOR<StopUpdateManyMutationInput, StopUncheckedUpdateManyWithoutRouteInput>
  }

  export type RouteFareUpsertWithWhereUniqueWithoutRouteInput = {
    where: RouteFareWhereUniqueInput
    update: XOR<RouteFareUpdateWithoutRouteInput, RouteFareUncheckedUpdateWithoutRouteInput>
    create: XOR<RouteFareCreateWithoutRouteInput, RouteFareUncheckedCreateWithoutRouteInput>
  }

  export type RouteFareUpdateWithWhereUniqueWithoutRouteInput = {
    where: RouteFareWhereUniqueInput
    data: XOR<RouteFareUpdateWithoutRouteInput, RouteFareUncheckedUpdateWithoutRouteInput>
  }

  export type RouteFareUpdateManyWithWhereWithoutRouteInput = {
    where: RouteFareScalarWhereInput
    data: XOR<RouteFareUpdateManyMutationInput, RouteFareUncheckedUpdateManyWithoutRouteInput>
  }

  export type RouteFareScalarWhereInput = {
    AND?: RouteFareScalarWhereInput | RouteFareScalarWhereInput[]
    OR?: RouteFareScalarWhereInput[]
    NOT?: RouteFareScalarWhereInput | RouteFareScalarWhereInput[]
    id?: StringFilter<"RouteFare"> | string
    routeId?: StringFilter<"RouteFare"> | string
    vehicleType?: StringFilter<"RouteFare"> | string
    pricingType?: StringFilter<"RouteFare"> | string
    baseFare?: FloatFilter<"RouteFare"> | number
    perKmRate?: FloatNullableFilter<"RouteFare"> | number | null
    perHourRate?: FloatNullableFilter<"RouteFare"> | number | null
    nightCharge?: FloatNullableFilter<"RouteFare"> | number | null
    hillCharge?: FloatNullableFilter<"RouteFare"> | number | null
    waitingCharge?: FloatNullableFilter<"RouteFare"> | number | null
    createdAt?: DateTimeFilter<"RouteFare"> | Date | string
    updatedAt?: DateTimeFilter<"RouteFare"> | Date | string
  }

  export type RouteAvailabilityUpsertWithWhereUniqueWithoutRouteInput = {
    where: RouteAvailabilityWhereUniqueInput
    update: XOR<RouteAvailabilityUpdateWithoutRouteInput, RouteAvailabilityUncheckedUpdateWithoutRouteInput>
    create: XOR<RouteAvailabilityCreateWithoutRouteInput, RouteAvailabilityUncheckedCreateWithoutRouteInput>
  }

  export type RouteAvailabilityUpdateWithWhereUniqueWithoutRouteInput = {
    where: RouteAvailabilityWhereUniqueInput
    data: XOR<RouteAvailabilityUpdateWithoutRouteInput, RouteAvailabilityUncheckedUpdateWithoutRouteInput>
  }

  export type RouteAvailabilityUpdateManyWithWhereWithoutRouteInput = {
    where: RouteAvailabilityScalarWhereInput
    data: XOR<RouteAvailabilityUpdateManyMutationInput, RouteAvailabilityUncheckedUpdateManyWithoutRouteInput>
  }

  export type RouteAvailabilityScalarWhereInput = {
    AND?: RouteAvailabilityScalarWhereInput | RouteAvailabilityScalarWhereInput[]
    OR?: RouteAvailabilityScalarWhereInput[]
    NOT?: RouteAvailabilityScalarWhereInput | RouteAvailabilityScalarWhereInput[]
    id?: StringFilter<"RouteAvailability"> | string
    routeId?: StringFilter<"RouteAvailability"> | string
    vehicleType?: StringFilter<"RouteAvailability"> | string
    isAvailable?: BoolFilter<"RouteAvailability"> | boolean
    reason?: StringNullableFilter<"RouteAvailability"> | string | null
    createdAt?: DateTimeFilter<"RouteAvailability"> | Date | string
    updatedAt?: DateTimeFilter<"RouteAvailability"> | Date | string
  }

  export type RouteCreateWithoutStopsInput = {
    id?: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    origin: LocationCreateNestedOneWithoutRoutesFromInput
    destination: LocationCreateNestedOneWithoutRoutesToInput
    fares?: RouteFareCreateNestedManyWithoutRouteInput
    availability?: RouteAvailabilityCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutStopsInput = {
    id?: string
    originId: string
    destinationId: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    fares?: RouteFareUncheckedCreateNestedManyWithoutRouteInput
    availability?: RouteAvailabilityUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutStopsInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutStopsInput, RouteUncheckedCreateWithoutStopsInput>
  }

  export type LocationCreateWithoutStopsInput = {
    id?: string
    name: string
    district: string
    state?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    routesFrom?: RouteCreateNestedManyWithoutOriginInput
    routesTo?: RouteCreateNestedManyWithoutDestinationInput
  }

  export type LocationUncheckedCreateWithoutStopsInput = {
    id?: string
    name: string
    district: string
    state?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    routesFrom?: RouteUncheckedCreateNestedManyWithoutOriginInput
    routesTo?: RouteUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type LocationCreateOrConnectWithoutStopsInput = {
    where: LocationWhereUniqueInput
    create: XOR<LocationCreateWithoutStopsInput, LocationUncheckedCreateWithoutStopsInput>
  }

  export type RouteUpsertWithoutStopsInput = {
    update: XOR<RouteUpdateWithoutStopsInput, RouteUncheckedUpdateWithoutStopsInput>
    create: XOR<RouteCreateWithoutStopsInput, RouteUncheckedCreateWithoutStopsInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutStopsInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutStopsInput, RouteUncheckedUpdateWithoutStopsInput>
  }

  export type RouteUpdateWithoutStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: LocationUpdateOneRequiredWithoutRoutesFromNestedInput
    destination?: LocationUpdateOneRequiredWithoutRoutesToNestedInput
    fares?: RouteFareUpdateManyWithoutRouteNestedInput
    availability?: RouteAvailabilityUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    originId?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fares?: RouteFareUncheckedUpdateManyWithoutRouteNestedInput
    availability?: RouteAvailabilityUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type LocationUpsertWithoutStopsInput = {
    update: XOR<LocationUpdateWithoutStopsInput, LocationUncheckedUpdateWithoutStopsInput>
    create: XOR<LocationCreateWithoutStopsInput, LocationUncheckedCreateWithoutStopsInput>
    where?: LocationWhereInput
  }

  export type LocationUpdateToOneWithWhereWithoutStopsInput = {
    where?: LocationWhereInput
    data: XOR<LocationUpdateWithoutStopsInput, LocationUncheckedUpdateWithoutStopsInput>
  }

  export type LocationUpdateWithoutStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routesFrom?: RouteUpdateManyWithoutOriginNestedInput
    routesTo?: RouteUpdateManyWithoutDestinationNestedInput
  }

  export type LocationUncheckedUpdateWithoutStopsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    district?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routesFrom?: RouteUncheckedUpdateManyWithoutOriginNestedInput
    routesTo?: RouteUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type RouteCreateWithoutFaresInput = {
    id?: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    origin: LocationCreateNestedOneWithoutRoutesFromInput
    destination: LocationCreateNestedOneWithoutRoutesToInput
    stops?: StopCreateNestedManyWithoutRouteInput
    availability?: RouteAvailabilityCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutFaresInput = {
    id?: string
    originId: string
    destinationId: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stops?: StopUncheckedCreateNestedManyWithoutRouteInput
    availability?: RouteAvailabilityUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutFaresInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutFaresInput, RouteUncheckedCreateWithoutFaresInput>
  }

  export type RouteUpsertWithoutFaresInput = {
    update: XOR<RouteUpdateWithoutFaresInput, RouteUncheckedUpdateWithoutFaresInput>
    create: XOR<RouteCreateWithoutFaresInput, RouteUncheckedCreateWithoutFaresInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutFaresInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutFaresInput, RouteUncheckedUpdateWithoutFaresInput>
  }

  export type RouteUpdateWithoutFaresInput = {
    id?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: LocationUpdateOneRequiredWithoutRoutesFromNestedInput
    destination?: LocationUpdateOneRequiredWithoutRoutesToNestedInput
    stops?: StopUpdateManyWithoutRouteNestedInput
    availability?: RouteAvailabilityUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutFaresInput = {
    id?: StringFieldUpdateOperationsInput | string
    originId?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stops?: StopUncheckedUpdateManyWithoutRouteNestedInput
    availability?: RouteAvailabilityUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteCreateWithoutAvailabilityInput = {
    id?: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    origin: LocationCreateNestedOneWithoutRoutesFromInput
    destination: LocationCreateNestedOneWithoutRoutesToInput
    stops?: StopCreateNestedManyWithoutRouteInput
    fares?: RouteFareCreateNestedManyWithoutRouteInput
  }

  export type RouteUncheckedCreateWithoutAvailabilityInput = {
    id?: string
    originId: string
    destinationId: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stops?: StopUncheckedCreateNestedManyWithoutRouteInput
    fares?: RouteFareUncheckedCreateNestedManyWithoutRouteInput
  }

  export type RouteCreateOrConnectWithoutAvailabilityInput = {
    where: RouteWhereUniqueInput
    create: XOR<RouteCreateWithoutAvailabilityInput, RouteUncheckedCreateWithoutAvailabilityInput>
  }

  export type RouteUpsertWithoutAvailabilityInput = {
    update: XOR<RouteUpdateWithoutAvailabilityInput, RouteUncheckedUpdateWithoutAvailabilityInput>
    create: XOR<RouteCreateWithoutAvailabilityInput, RouteUncheckedCreateWithoutAvailabilityInput>
    where?: RouteWhereInput
  }

  export type RouteUpdateToOneWithWhereWithoutAvailabilityInput = {
    where?: RouteWhereInput
    data: XOR<RouteUpdateWithoutAvailabilityInput, RouteUncheckedUpdateWithoutAvailabilityInput>
  }

  export type RouteUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: LocationUpdateOneRequiredWithoutRoutesFromNestedInput
    destination?: LocationUpdateOneRequiredWithoutRoutesToNestedInput
    stops?: StopUpdateManyWithoutRouteNestedInput
    fares?: RouteFareUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    originId?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stops?: StopUncheckedUpdateManyWithoutRouteNestedInput
    fares?: RouteFareUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type SearchHistoryCreateManyUserInput = {
    id?: string
    search_query: string
    latitude?: number | null
    longitude?: number | null
    search_count?: number
    first_searched?: Date | string
    last_searched?: Date | string
    user_type?: string
    device?: string | null
    is_successful?: boolean
    converted_to_booking?: boolean
    booking_id?: string | null
    session_id?: string | null
    source_page?: string | null
    search_category?: string | null
    estimated_distance?: number | null
    estimated_duration?: number | null
    peak_hour_search?: boolean
    region?: string | null
    city?: string | null
    state?: string | null
    search_completion_rate?: number | null
    user_agent?: string | null
    ip_address?: string | null
    referral_source?: string | null
    time_to_result?: number | null
    competitor_price_check?: boolean
    potential_revenue?: number | null
    seasonal_factor?: number | null
    market_demand_score?: number | null
  }

  export type SearchHistoryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    search_query?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    search_count?: IntFieldUpdateOperationsInput | number
    first_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    last_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    user_type?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    is_successful?: BoolFieldUpdateOperationsInput | boolean
    converted_to_booking?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    source_page?: NullableStringFieldUpdateOperationsInput | string | null
    search_category?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_duration?: NullableIntFieldUpdateOperationsInput | number | null
    peak_hour_search?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    search_completion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source?: NullableStringFieldUpdateOperationsInput | string | null
    time_to_result?: NullableIntFieldUpdateOperationsInput | number | null
    competitor_price_check?: BoolFieldUpdateOperationsInput | boolean
    potential_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    seasonal_factor?: NullableFloatFieldUpdateOperationsInput | number | null
    market_demand_score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SearchHistoryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    search_query?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    search_count?: IntFieldUpdateOperationsInput | number
    first_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    last_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    user_type?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    is_successful?: BoolFieldUpdateOperationsInput | boolean
    converted_to_booking?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    source_page?: NullableStringFieldUpdateOperationsInput | string | null
    search_category?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_duration?: NullableIntFieldUpdateOperationsInput | number | null
    peak_hour_search?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    search_completion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source?: NullableStringFieldUpdateOperationsInput | string | null
    time_to_result?: NullableIntFieldUpdateOperationsInput | number | null
    competitor_price_check?: BoolFieldUpdateOperationsInput | boolean
    potential_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    seasonal_factor?: NullableFloatFieldUpdateOperationsInput | number | null
    market_demand_score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SearchHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    search_query?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    search_count?: IntFieldUpdateOperationsInput | number
    first_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    last_searched?: DateTimeFieldUpdateOperationsInput | Date | string
    user_type?: StringFieldUpdateOperationsInput | string
    device?: NullableStringFieldUpdateOperationsInput | string | null
    is_successful?: BoolFieldUpdateOperationsInput | boolean
    converted_to_booking?: BoolFieldUpdateOperationsInput | boolean
    booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    session_id?: NullableStringFieldUpdateOperationsInput | string | null
    source_page?: NullableStringFieldUpdateOperationsInput | string | null
    search_category?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_distance?: NullableFloatFieldUpdateOperationsInput | number | null
    estimated_duration?: NullableIntFieldUpdateOperationsInput | number | null
    peak_hour_search?: BoolFieldUpdateOperationsInput | boolean
    region?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    search_completion_rate?: NullableFloatFieldUpdateOperationsInput | number | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    referral_source?: NullableStringFieldUpdateOperationsInput | string | null
    time_to_result?: NullableIntFieldUpdateOperationsInput | number | null
    competitor_price_check?: BoolFieldUpdateOperationsInput | boolean
    potential_revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    seasonal_factor?: NullableFloatFieldUpdateOperationsInput | number | null
    market_demand_score?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RouteCreateManyOriginInput = {
    id?: string
    destinationId: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteCreateManyDestinationInput = {
    id?: string
    originId: string
    directionType: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StopCreateManyLocationInput = {
    id?: string
    routeId: string
    name: string
    order: number
    distanceKm?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteUpdateWithoutOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: LocationUpdateOneRequiredWithoutRoutesToNestedInput
    stops?: StopUpdateManyWithoutRouteNestedInput
    fares?: RouteFareUpdateManyWithoutRouteNestedInput
    availability?: RouteAvailabilityUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stops?: StopUncheckedUpdateManyWithoutRouteNestedInput
    fares?: RouteFareUncheckedUpdateManyWithoutRouteNestedInput
    availability?: RouteAvailabilityUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateManyWithoutOriginInput = {
    id?: StringFieldUpdateOperationsInput | string
    destinationId?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: LocationUpdateOneRequiredWithoutRoutesFromNestedInput
    stops?: StopUpdateManyWithoutRouteNestedInput
    fares?: RouteFareUpdateManyWithoutRouteNestedInput
    availability?: RouteAvailabilityUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originId?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stops?: StopUncheckedUpdateManyWithoutRouteNestedInput
    fares?: RouteFareUncheckedUpdateManyWithoutRouteNestedInput
    availability?: RouteAvailabilityUncheckedUpdateManyWithoutRouteNestedInput
  }

  export type RouteUncheckedUpdateManyWithoutDestinationInput = {
    id?: StringFieldUpdateOperationsInput | string
    originId?: StringFieldUpdateOperationsInput | string
    directionType?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    route?: RouteUpdateOneRequiredWithoutStopsNestedInput
  }

  export type StopUncheckedUpdateWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopUncheckedUpdateManyWithoutLocationInput = {
    id?: StringFieldUpdateOperationsInput | string
    routeId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopCreateManyRouteInput = {
    id?: string
    locationId: string
    name: string
    order: number
    distanceKm?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteFareCreateManyRouteInput = {
    id?: string
    vehicleType: string
    pricingType: string
    baseFare: number
    perKmRate?: number | null
    perHourRate?: number | null
    nightCharge?: number | null
    hillCharge?: number | null
    waitingCharge?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RouteAvailabilityCreateManyRouteInput = {
    id?: string
    vehicleType: string
    isAvailable?: boolean
    reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StopUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    location?: LocationUpdateOneRequiredWithoutStopsNestedInput
  }

  export type StopUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StopUncheckedUpdateManyWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    locationId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    distanceKm?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteFareUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    pricingType?: StringFieldUpdateOperationsInput | string
    baseFare?: FloatFieldUpdateOperationsInput | number
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    perHourRate?: NullableFloatFieldUpdateOperationsInput | number | null
    nightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    hillCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    waitingCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteFareUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    pricingType?: StringFieldUpdateOperationsInput | string
    baseFare?: FloatFieldUpdateOperationsInput | number
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    perHourRate?: NullableFloatFieldUpdateOperationsInput | number | null
    nightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    hillCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    waitingCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteFareUncheckedUpdateManyWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    pricingType?: StringFieldUpdateOperationsInput | string
    baseFare?: FloatFieldUpdateOperationsInput | number
    perKmRate?: NullableFloatFieldUpdateOperationsInput | number | null
    perHourRate?: NullableFloatFieldUpdateOperationsInput | number | null
    nightCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    hillCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    waitingCharge?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteAvailabilityUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteAvailabilityUncheckedUpdateWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteAvailabilityUncheckedUpdateManyWithoutRouteInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleType?: StringFieldUpdateOperationsInput | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}